<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>COA on VZstless</title>
        <link>https://vzstless.moe/tags/coa/</link>
        <description>Recent content in COA on VZstless</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>VZstless</copyright>
        <lastBuildDate>Sat, 25 Jan 2025 11:45:07 +0800</lastBuildDate><atom:link href="https://vzstless.moe/tags/coa/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>龙芯杯讲座笔记</title>
        <link>https://vzstless.moe/p/%E9%BE%99%E8%8A%AF%E6%9D%AF%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 25 Jan 2025 11:45:07 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E9%BE%99%E8%8A%AF%E6%9D%AF%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;龙芯杯介绍&#34;&gt;龙芯杯介绍
&lt;/h2&gt;&lt;p&gt;龙芯杯：CPU设计相关&lt;br&gt;
第9届&lt;br&gt;
loongarch类似于RISC-V&lt;/p&gt;
&lt;p&gt;初赛：CPU+L1 cache&lt;br&gt;
决赛配SoC外设和PMON BIOS&lt;br&gt;
团队赛发平台&lt;/p&gt;
&lt;p&gt;三月开始报名，八月上旬交初赛作品，八月中旬提交决赛作品&lt;br&gt;
个人赛名额不限&lt;/p&gt;
&lt;p&gt;按照官方接口实现指令集的正确性与性能，完全客观评分&lt;br&gt;
决赛：启动相关设施&lt;br&gt;
半天时间接一条指令&lt;/p&gt;
&lt;p&gt;三等奖以上可进行加分&lt;br&gt;
2022年第一次接触loongarch架构&lt;/p&gt;
&lt;h2 id=&#34;个人赛经验分享&#34;&gt;个人赛经验分享
&lt;/h2&gt;&lt;p&gt;个人赛：决赛100分，基准测试运行70%，编程任务30%&lt;br&gt;
纯粹的性能比拼
比较运行时间，只要运行时间足够短就行&lt;br&gt;
运行时间=指令数/每秒指令数&lt;/p&gt;
&lt;p&gt;提升IPC的思路：
普通运算CPI=1，乘法CPI=2，访存CPI=3&lt;br&gt;
条件分支需要分支预测相关&lt;/p&gt;
&lt;p&gt;CPU微架构设计决定了IPC&lt;/p&gt;
&lt;p&gt;编码技巧，流水级数的划分，布线质量和资源占用数&lt;br&gt;
设计简单，频率反而高&lt;br&gt;
FPGA芯片的体质可能不同&lt;br&gt;
有些部件的加入可能反而使性能下降&lt;/p&gt;
&lt;p&gt;面向测试程序进行设计&lt;br&gt;
内存复制，矩阵乘法，哈希算法&lt;br&gt;
观察发现程序1访存极其规律，矩阵乘法也比较规律，第三个程序访存就具有很大的随机性了&lt;br&gt;
乱序多发射性价比不高，提升主频是有效的&lt;br&gt;
程序2可能需要stride进行预取&lt;/p&gt;
&lt;p&gt;大量的时间花在了访存上，数据预取&lt;br&gt;
使用1bit BHT 或者 BTB也可&lt;/p&gt;
&lt;p&gt;有可挖掘的指令并行性，但是性价比不高&lt;br&gt;
实现指令cache很有必要&lt;br&gt;
实现分支预测器，写缓冲器的性价比较高&lt;br&gt;
实现数据预测器、数据cache和乱序多发射的性价比较低，不如考虑提升频率&lt;/p&gt;
&lt;p&gt;提升频率？在vivado的PLL IP中设置&lt;br&gt;
但是由于触发器有setup time，在下一个数据到来之前数据必须保持稳定的时间&lt;/p&gt;
&lt;p&gt;WNS：时钟周期与满足所需约束的差值，当WNS &amp;lt; 0时电路时序可能无法保证&lt;br&gt;
超频：只能说是最后的手段&lt;/p&gt;
&lt;p&gt;使用时序分析工具&lt;br&gt;
implementation -&amp;gt; Report timing summary&lt;br&gt;
列出路径，理解是从什么部件到什么部件的关键路径&lt;br&gt;
使用vivado对路径进行画图&lt;/p&gt;
&lt;p&gt;更合理地划分流水等级&lt;br&gt;
选择在哪里切一刀进行划分&lt;/p&gt;
&lt;p&gt;数据cache：IPC↑，BRAM资源占用↑&lt;br&gt;
数据预取：IPC↑，逻辑复杂，不利于超频&lt;br&gt;
乱序多发射：IPC↑，逻辑变复杂，不利于超频&lt;/p&gt;
&lt;p&gt;编码技巧：vivado user guide&lt;br&gt;
使用更加激进的综合实现策略，最终还能带来10-20MHz的性能提升&lt;br&gt;
个人赛的优化思路已经被挖的差不多了&lt;/p&gt;
&lt;h2 id=&#34;团队赛经验分享&#34;&gt;团队赛经验分享
&lt;/h2&gt;&lt;p&gt;特等奖：性能/功能重大创新&lt;br&gt;
一等奖：Linux+性能优秀&lt;br&gt;
二等奖：能跑操作系统&lt;br&gt;
三等奖：能跑测试程序&lt;/p&gt;
&lt;p&gt;CPU：超大工作量，SoC：大工作量，系统软件：中等工作量&lt;br&gt;
正确性保证，性能调优，丰富功能&lt;/p&gt;
&lt;p&gt;比较推荐Chisel和Spinal，面向功能写代码，上手难度低&lt;br&gt;
基于其它语言的HDL扩展玩具性质较强，不太方便使用&lt;br&gt;
乱序执行，多级流水线，分支预测，cache，TLB，MMU&lt;/p&gt;
&lt;p&gt;参考往年开源方案，参考香山处理器微架构文档&lt;/p&gt;
&lt;p&gt;CPU实现要点：简化设计&lt;br&gt;
前端和后端实现，模块化实现&lt;br&gt;
尽量保证不同模块之间是黑盒&lt;br&gt;
分支预测和cache可以和cpu分开开发&lt;br&gt;
浮点指令集等到启动Linux之后再做&lt;/p&gt;
&lt;p&gt;参考书目：&lt;br&gt;
计算机体系结构教材，超标量处理器设计，CPU设计实战&lt;/p&gt;
&lt;p&gt;流程：
开学前4人现在chiplab完成CPU设计实战的实验部分&lt;br&gt;
开学后两人完成CPU设计，完成乱序和超标量部分&lt;br&gt;
一人完成SoC，使用现成的CPU做&lt;br&gt;
一人完成分支预测，cache和系统适配等&lt;/p&gt;
&lt;p&gt;官方的trace太弱，很多问题测不出来&lt;br&gt;
三步走：确保在最小的SoC上运行Linux&lt;br&gt;
做出自己的SoC，支持更多外设&lt;br&gt;
丰富系统软件&lt;br&gt;
只有CPU强制要求自行实现&lt;/p&gt;
&lt;p&gt;SoC：使用vivado block design&lt;br&gt;
外设控制器，重视扩展I/O口&lt;/p&gt;
&lt;p&gt;软件系统部署：
PMON/u-boot，片上ROM/片外flash&lt;br&gt;
只需要加载Linux内核elf即可&lt;br&gt;
Linux内核：载入内存，正确配置设备树和驱动程序&lt;br&gt;
根文件系统：busybox，buildroot，移植libc等运行库&lt;br&gt;
应用软件：编译开源代码&lt;br&gt;
推荐方向：物联网，网络应用，游戏应用&lt;br&gt;
AI应用，发行版Linux中前者算力受限后者板载内存受限 &lt;br&gt;
24年特等奖的GUI界面&lt;/p&gt;
</description>
        </item>
        <item>
        <title>单周期处理器（LA）讲座笔记</title>
        <link>https://vzstless.moe/p/%E5%8D%95%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8la%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Tue, 10 Dec 2024 16:55:17 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E5%8D%95%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8la%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;单周期处理器la版本&#34;&gt;单周期处理器（LA版本）
&lt;/h2&gt;&lt;p&gt;延迟槽：曾几何时它很好，然而它非但无法解决延迟造成的流水线阻塞问题，而且会使微结构的设计复杂化，而且编译器并不能总是提取出有效指令填入流水线导致流水线中出现过量空指令，影响流水线性能&lt;/p&gt;
&lt;p&gt;支持远距离跳转的指令集可以更好减少由于代码体积增大而产生的效率降低问题&lt;/p&gt;
&lt;p&gt;跳转后还要从寄存器中获得对应的地址，故称间接跳转，link用于返回地址的链接&lt;/p&gt;
&lt;p&gt;去掉unsigned的指令集依然是完整的&lt;/p&gt;
&lt;p&gt;至少需要一条syscall才能使用操作系统，否则指令集无法区分用户态和核心态&lt;/p&gt;
&lt;p&gt;务必注意当input的取值是最后一个值的时候的output&lt;/p&gt;
&lt;p&gt;CPU = 数据通路 + 控制逻辑&lt;/p&gt;
&lt;p&gt;指令在指令存储器中存储，地址为PC&lt;/p&gt;
&lt;p&gt;每执行完一条指令，PC = PC + 4&lt;/p&gt;
&lt;p&gt;指令存储器是一个静态存储器，所有写的端口恒为0&lt;/p&gt;
&lt;p&gt;add.w: 从寄存器堆读取操作数，相加，写回寄存器堆&lt;/p&gt;
&lt;p&gt;寄存器堆的读端口必须有两个，否则执行add需要两个周期；而写端口要有enable（或者reset）&lt;/p&gt;
&lt;p&gt;addi.w: 与add.w唯一的区别就是第二个源操作数来自指令集中立即数符号扩展至32位&lt;/p&gt;
&lt;p&gt;ld.w可以复用addi.w的数据通路，ld.w从从数据存储器中读取数据，取回的数据与加法器结果二选一放入寄存器堆&lt;/p&gt;
&lt;p&gt;st.w写数据存储器，不写寄存器堆&lt;/p&gt;
&lt;p&gt;务必注意：st.w的源操作数来自rd域，因为增加一个读端口会增加硬件开销&lt;/p&gt;
&lt;p&gt;dest bne = PC + offset&lt;/p&gt;
&lt;p&gt;bne根据判断的结果决定是否跳转&lt;/p&gt;
&lt;p&gt;每次加指令时进行的检查：本条指令是否正确运行，已有的指令功能是否正常&lt;/p&gt;
&lt;p&gt;zero寄存器的作用就是减少实现指令集子集时的xor&lt;/p&gt;
&lt;p&gt;编写控制信号的真值表&lt;/p&gt;
&lt;p&gt;存储器本质上属于核外单元，一些实际的案例中CPU的最顶层只有CLK和RESET&lt;/p&gt;
&lt;p&gt;现如今的EDA几乎可以把电路性能优化到极致，所以要以可读性与可维护性作为更高的目标&lt;/p&gt;
&lt;p&gt;不要写真值表，画卡诺图，直接对照指令的机器码格式和电路图敲Verilog&lt;/p&gt;
&lt;p&gt;多一条assign可以提高代码可读性&lt;/p&gt;
&lt;p&gt;b: 立即数增宽至26位&lt;/p&gt;
&lt;p&gt;bl:b之后将PC + 4写入r1（单周期甚至可以直接拉线到MUX写入）&lt;/p&gt;
&lt;p&gt;新增的控制信号依然要考虑所有的指令&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Csapp Chapter4</title>
        <link>https://vzstless.moe/p/csapp-chapter4/</link>
        <pubDate>Tue, 10 Dec 2024 16:44:47 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/csapp-chapter4/</guid>
        <description>&lt;h2 id=&#34;41&#34;&gt;4.1
&lt;/h2&gt;&lt;h3 id=&#34;prelude&#34;&gt;prelude
&lt;/h3&gt;&lt;p&gt;PC holds the address of the instruction that currently executed.&lt;/p&gt;
&lt;p&gt;registers, base pointer, stack pointer&lt;/p&gt;
&lt;p&gt;condition code: ZF, SF, OF&lt;/p&gt;
&lt;p&gt;memory(monolithic byte array)&lt;/p&gt;
&lt;p&gt;Types of encoding the Y-86 instructions:&lt;/p&gt;
&lt;p&gt;I-type, D-type and B-type&lt;/p&gt;
&lt;h3 id=&#34;instructions&#34;&gt;instructions
&lt;/h3&gt;&lt;p&gt;movq is split: I, R, M -&amp;gt; R, M&lt;/p&gt;
&lt;p&gt;AL instructions: addq, subq, andq, xorq (as there is no zero register in Y-86 processor, you must add an xorq instruction)&lt;/p&gt;
&lt;p&gt;jumps: jmp, &amp;lt;=, &amp;lt;, ==, !=, &amp;gt;=, &amp;gt;&lt;/p&gt;
&lt;p&gt;cond move: &amp;lt;=, &amp;lt;, ==, !=, &amp;gt;=, &amp;gt;&lt;/p&gt;
&lt;p&gt;halt: stops the program&lt;/p&gt;
&lt;h3 id=&#34;encode&#34;&gt;encode
&lt;/h3&gt;&lt;p&gt;code + function&lt;/p&gt;
&lt;p&gt;store in a small RAM&lt;/p&gt;
&lt;p&gt;no ambiguity when encoding the instructions&lt;/p&gt;
&lt;p&gt;Y86-64 is CISC-like for its various length of instructions and RISC-like for its single load/store encoding&lt;/p&gt;
&lt;h3 id=&#34;exceptions&#34;&gt;exceptions
&lt;/h3&gt;&lt;p&gt;AOK, HLT, ADR, INS&lt;/p&gt;
&lt;p&gt;shut whenever not AOK&lt;/p&gt;
&lt;h3 id=&#34;run-a-code&#34;&gt;run a code
&lt;/h3&gt;&lt;p&gt;addq needs another register but subq can also set the stat code&lt;/p&gt;
&lt;p&gt;pushq and popq&amp;rsquo;s details may largely reduce the code portability, problem may occur when subq compares rsp and the pushed value, or pop the stack pointer, undefined behavior always annoy people anytime anywhere.&lt;/p&gt;
&lt;h2 id=&#34;42&#34;&gt;4.2
&lt;/h2&gt;&lt;h3 id=&#34;components&#34;&gt;components
&lt;/h3&gt;&lt;p&gt;combinational logic, memory elements, clock signals(sequential logic is split into two parts)&lt;/p&gt;
&lt;p&gt;similarity: Verilog -&amp;gt; C, VHDL -&amp;gt; Ada&lt;/p&gt;
&lt;p&gt;HCL == block:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bool eq = (a &amp;amp;&amp;amp; b) || (!a &amp;amp;&amp;amp; !b)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;HCL MUX block:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bool out = (s &amp;amp;&amp;amp; a) || ()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;word level: using cases&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;word Out = [
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	s: A;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	1: B;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;sequential-logic&#34;&gt;sequential logic
&lt;/h3&gt;&lt;p&gt;reg &amp;amp; RAM&lt;/p&gt;
&lt;p&gt;state changes only when clock rises&lt;/p&gt;
&lt;p&gt;simple regfile:&lt;/p&gt;
&lt;p&gt;valA, valB, srcA, srcB, dstW, valW&lt;/p&gt;
&lt;p&gt;in the Y86 processor: a memory with 2 ports, one for R inst, the other for R/W data&lt;/p&gt;
&lt;h2 id=&#34;43&#34;&gt;4.3
&lt;/h2&gt;&lt;h3 id=&#34;stages-of-instructions&#34;&gt;stages of instructions
&lt;/h3&gt;&lt;h4 id=&#34;fetch&#34;&gt;Fetch
&lt;/h4&gt;&lt;p&gt;PC = memaddr&lt;/p&gt;
&lt;p&gt;valP = PC + len(inst)&lt;/p&gt;
&lt;h4 id=&#34;decode&#34;&gt;Decode
&lt;/h4&gt;&lt;p&gt;read operands from reg file&lt;/p&gt;
&lt;h4 id=&#34;execute&#34;&gt;Execute
&lt;/h4&gt;&lt;p&gt;ALU performs instruction or incr/decr the stack pointer, for other instruction, similar&lt;/p&gt;
&lt;h4 id=&#34;memory&#34;&gt;Memory
&lt;/h4&gt;&lt;p&gt;W/R data in mem&lt;/p&gt;
&lt;h4 id=&#34;write-back&#34;&gt;Write back
&lt;/h4&gt;&lt;p&gt;write back to register&lt;/p&gt;
&lt;h4 id=&#34;pc-update&#34;&gt;PC update
&lt;/h4&gt;&lt;p&gt;PC stores addr of next instruction&lt;/p&gt;
&lt;p&gt;cost of adding hardware &amp;gt; cost of copying code in software&lt;/p&gt;
&lt;p&gt;process similar instructions in same manners&lt;/p&gt;
&lt;h3 id=&#34;hardware&#34;&gt;Hardware
&lt;/h3&gt;&lt;p&gt;Fetch: PC computes valP, the incremented PC.&lt;/p&gt;
&lt;p&gt;Decode: read valA and valB&lt;/p&gt;
&lt;p&gt;Execute: ALU calculates integer or increments the stack pointer, decides whether jump or not.&lt;/p&gt;
&lt;p&gt;Memory: read or write a word of mem&lt;/p&gt;
&lt;p&gt;Write Back: write back from ALU or mem&lt;/p&gt;
&lt;p&gt;PC update&lt;/p&gt;
&lt;p&gt;only start next cycle when clock rises&lt;/p&gt;
&lt;p&gt;processor never read back&lt;/p&gt;
&lt;p&gt;eg: no instruction will both set and read the cond code&lt;/p&gt;
&lt;p&gt;eg: stack pointer&lt;/p&gt;
&lt;p&gt;fetch: fetching 6 bytes and generate instruction fields.&lt;/p&gt;
&lt;p&gt;decode &amp;amp; write back: generate register identifiers, serve necessary data.&lt;/p&gt;
&lt;p&gt;execute: ALU performs as the calculator or just the adder.&lt;/p&gt;
&lt;p&gt;memory: write or read memory values.&lt;/p&gt;
&lt;p&gt;PC increment: depend on instruction code or branch or not.&lt;/p&gt;
&lt;h3 id=&#34;survey&#34;&gt;Survey
&lt;/h3&gt;&lt;p&gt;the clock must run slow enough to suit the single-cycle.&lt;/p&gt;
&lt;p&gt;the parts of the processor only active for a single part of time in the clock cycle&lt;/p&gt;
&lt;h2 id=&#34;44&#34;&gt;4.4
&lt;/h2&gt;&lt;h3 id=&#34;pipelining&#34;&gt;pipelining
&lt;/h3&gt;&lt;p&gt;divide into a series of discrete stages&lt;/p&gt;
&lt;p&gt;increase the throughput of a system, but slightly increase the latency&lt;/p&gt;
&lt;p&gt;nonpipelined: a logic performs the computation with a register hold the result of the computation&lt;/p&gt;
&lt;p&gt;latency: the total time to perform a single instruction&lt;/p&gt;
&lt;p&gt;slowing the clock won&amp;rsquo;t change the behavior of a pipeline.&lt;/p&gt;
&lt;p&gt;different clock delays of different instructions influences the pipeline,&lt;/p&gt;
&lt;p&gt;due to the delay, pipeline doesn&amp;rsquo;t always have larger throughput with more stages on each instruction&lt;/p&gt;
&lt;p&gt;logical dependencies limits the performance of pipeline&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
