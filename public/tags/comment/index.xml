<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>COMMENT on VZstless</title>
        <link>https://vzstless.moe/tags/comment/</link>
        <description>Recent content in COMMENT on VZstless</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>VZstless</copyright>
        <lastBuildDate>Wed, 20 Aug 2025 07:18:16 +0800</lastBuildDate><atom:link href="https://vzstless.moe/tags/comment/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>关于电脑的问与答</title>
        <link>https://vzstless.moe/p/%E5%85%B3%E4%BA%8E%E7%94%B5%E8%84%91%E7%9A%84%E9%97%AE%E4%B8%8E%E7%AD%94/</link>
        <pubDate>Wed, 20 Aug 2025 07:18:16 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E5%85%B3%E4%BA%8E%E7%94%B5%E8%84%91%E7%9A%84%E9%97%AE%E4%B8%8E%E7%AD%94/</guid>
        <description>&lt;h2 id=&#34;什么是电脑&#34;&gt;什么是电脑？
&lt;/h2&gt;&lt;p&gt;电脑是一种能够对同级别设备与其他设备进行底层修改或更高层级修改的工具。&lt;br&gt;
举例来说，电脑可以给电脑装系统，电脑可以给手机刷机，电脑也可以给平板装系统，电脑也可以制作别的设备的启动盘甚至挂载其他的文件系统。&lt;/p&gt;
&lt;h2 id=&#34;电脑的最显著特征是什么或者说电脑的思维是什么&#34;&gt;电脑的最显著特征是什么，或者说电脑的思维是什么？
&lt;/h2&gt;&lt;p&gt;电脑在解决任何问题都一定寻求精确解而非近似解。它能够保证所有的问题都可以通过点点点/敲命令行来解决，而非去刻意强调体验的趋同性。绝大多数如今市面上的所谓“电脑替代品”都在追求体验的趋同，这就是典型的近似解而非精确解。&lt;/p&gt;
&lt;h2 id=&#34;你对macos的评价如何&#34;&gt;你对macOS的评价如何？
&lt;/h2&gt;&lt;p&gt;它被炒作得太厉害了。&lt;/p&gt;
&lt;p&gt;你在某些视频平台上一旦碰见windows就是故障频发，屏蔽更新，全球事件，碰见macOS就是效率秘籍，转mac大法，碰见Linux就是狗都不用，装什么装。真的，你看见了你也得爆两句粗口。不知道还以为苹果成了他们爹了，怎么就这么能装，觉得自己这么高净值呢，哦高净值人群甚至不care你们这帮人口中的效率工具，你们又如何是好呢？&lt;/p&gt;
&lt;p&gt;最极端的例子就是某些“程序员”，把笔记软件，浏览器，IDE，鼠标控件，平滑窗口控件之类的东西见一个配一个，你就感觉这帮人是不是平常喝奶茶也这么喜欢加小料。看着Arc出来了，配！效率神器！看见Dia出来了，配！效率神器！这种人我就送一句摄影圈常用的话：摄影最重要的不是相机前面的那个头，而是相机后面的那个头。&lt;/p&gt;
&lt;p&gt;身边我也见过许多人觉得macOS的设置过于不直观了，我说那不叫不直观，而是macOS在设计之初就在力求移动端和桌面端操作的“神似”。当一个设置选项不直观的时候，思考一下如果在手机上这样做是不是很直观，你就能理解macOS设计的脑回路了。&lt;/p&gt;
&lt;p&gt;于我而言，虽然我没系统性用过macOS，但是我依然能够指出macOS最大的几处硬伤。&lt;/p&gt;
&lt;p&gt;一是macOS的软件分发模式拥有大量的历史残余。它的软件分发模式更像是本世纪初那种在apple store以光盘形式分发软件的模式而不是开源软件和订阅制软件的基于互联网分发的模式。在本世纪初“信息化”还是一个新名词的时间中，iBook和iWork套件的合购能够做到开袋即食，而今天不是，今天在电脑上人们做着各种各样的事情，人们希望电脑是为未来提供扩展性的工具而非只是注重一时的简便。这一历史残余导致了macOS上包管理器的缺失与App Store的姗姗来迟与功能残缺。&lt;/p&gt;
&lt;p&gt;二是macOS是一个严重依赖GUI的操作系统。这一点甚至比Windows还恶劣。Windows的“难用”是混乱和尾大不掉，而macOS的难用是一种思维定势。你会发现除了Swift，macOS似乎并不注重程序员和持久化用户的需求而是力求让系统变得更华丽，更傻瓜。另一个角度来说，macOS的FS Hierarchy和default shell随着系统的更新一变再变，对于高度关注问题根源的人来说这一点无疑是致命的。&lt;/p&gt;
&lt;p&gt;三是macOS是自由的。FS Hierarchy的事情我说过了，还有更严重的。这里没有lscpu，没有wget，许多你在Linux上耳熟能详信手拈来的命令行工具在这里是不好用甚至是不能用的。对于macOS来说，自动化你应该用我的Apple Script，性能监测你应该用我自己的任务管理器，出问题你不应该用dmesg而是用我的诊断工具，从网上下载东西你应该用我的Safari Toolkit而不是自己抓取或右键下载，甚至玩游戏你也应该先想着我的Apple Arcade而不是自己去什么Steam之类的平台搞。这种“自由”实际上就是损害用户的选择权，比Windows的“有选择权而难用”更加恶劣。&lt;/p&gt;
&lt;h2 id=&#34;那你推荐用linux吗&#34;&gt;那你推荐用Linux吗？
&lt;/h2&gt;&lt;p&gt;我对某些系统颇有微词只是反驳某些人的吹捧与炒作。Linux确实于我而言是“好用”，但我/我们与市面上绝大多数人的需求是有很大差异的。我们口中的“好用”大概率指的是“可修改性”或“可扩展性”，而绝大多数人口中的“好用”指的是“啥瓜”和“亲民”。这就注定了如果我硬搬我自己的经验给别人会出现高度的不适应。对于Linux我的态度从来不是“推荐”，而是“它是一种工具”。其他两家系统亦然。&lt;/p&gt;
&lt;h2 id=&#34;你现在用的是什么组合&#34;&gt;你现在用的是什么组合？
&lt;/h2&gt;&lt;p&gt;我现在使用的是ROG Zephyrus G14，Windows 11 24H2作为生活而WSL Debian和WSL NixOS是工作。未来我大概率会转向NixOS系统的MacBook，而将Windows空出来改为AtlasOS之类的系统专门用于生活使用。是的，如果你财力雄厚，双持是个不错的选择，反之，对于许多人中“双持”很好用的“副机”，如果直接推荐给别人作为主力机，大概率会遭到口诛笔伐。&lt;/p&gt;
&lt;p&gt;顺带一提，最好不要和他人骂战什么系统好或不好，说特点，而不是对喷，这对双方的用户都不好。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>浅谈MIT-6.102</title>
        <link>https://vzstless.moe/p/%E6%B5%85%E8%B0%88mit-6.102/</link>
        <pubDate>Thu, 15 May 2025 19:45:58 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E6%B5%85%E8%B0%88mit-6.102/</guid>
        <description>&lt;p&gt;常看我博客的朋友应该知道，我一直对软件工程这样集中于“生产关系”的学科不屑一顾。一部分原因是校内这些明面上搞“软件工程”的人每天就在研究GUI是不是所谓的“反人类”，然后研究在各种各样的corner case怎么用一个error来告诉用户我们崩了。你要光研究这个那还说啥呢？最后搞计算机的看本专业的所谓“管理学”不行，还得和隔壁的经管系取经，耽误了大量的时间，还把计算机真正该研究的东西变成了“黑箱”。&lt;br&gt;
然而MIT-6.102不是这样的，它是一个全方位的习惯培养。先告诉你当你单人工作的时候怎么做可维护，问题早出现早治疗的程序，再告诉你团队里的人可以使用什么方法来使得一个更大规模的项目怎么做得更优雅，最后深入语言的实现细节，告诉你什么该用什么不该用。最后还做了一个关于五线谱的小型语言进行这些概念的实践。可以说，软件工程在这里真正变成了一个身体力行的学科，而不是所谓的“生产关系”的嘴炮与空谈，更不是挪移给经管系的高高在上还没什么用的课程。&lt;br&gt;
另一面，你可以透过这节课对Rust祛魅。把变量设置在最小的可用范围，让绝大多数的变量不可变，注意内存问题，并发的时候善用promise，加入静态类型检查，加入对函数式编程的思想与内容&amp;hellip;&amp;hellip;你可以惊艳于这些“身体力行”的概念在十多年前便经由一门语言实现了，也可以明白那些执迷于所谓“Rust至上”的人为何愚蠢——既然这一切是身体力行的理念，那为什么不自己实践一下呢？&lt;/p&gt;
</description>
        </item>
        <item>
        <title>OSTEP为什么好</title>
        <link>https://vzstless.moe/p/ostep%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A5%BD/</link>
        <pubDate>Mon, 28 Apr 2025 14:33:15 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/ostep%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A5%BD/</guid>
        <description>&lt;p&gt;断断续续把OSTEP看完了，最开始看内存虚拟化的时候弃掉了一段时间，后来又捡了回来，因为别的OS textbook太烂了😂&lt;br&gt;
为什么OSTEP好？说实话，免费反而是最后要提及的有点，除了美国那边课本死贵死贵之外感觉国内的课本基本上要么用二手要么直接下电子版的了。一本Operating System Concepts哪怕是国内的大黑书也要158一本，不过又有多少人会买呢？&lt;br&gt;
首先一个好的地方是这本书没有过分聚焦到COA或者ICS应当聚焦的部分，直截了当地告诉你操作系统在哪儿，解决了你在COA或者ICS中没碰见的什么问题。OSC和MOS两本书都是要先给你满嘴口水地讲COA和ICS中嚼烂的内容，估计也就学唐XX计组没学明白的人需要这些内容了吧&amp;hellip;&amp;hellip;当然，硬盘的基本原理它还是给你讲了讲，防止你文件系统直接抓瞎（但其实这个部分可以砍掉，既然你第一章推荐了csapp那这部分可以默认讲过）&lt;br&gt;
其次就是真实。告诉你历史上怎么做的，怎么演化成如今的样子的。几乎所有的示例都会附上对应的在真实世界中能用的API示例代码。这里的一个反例就是MOS，过分地“又臭又长”，而且示例代码还不那么make sense。重点是每章后方的参考文献都给了你阅读指导，告诉你你不仅应该看这本书，还应该再看看这些内容的相关一手消息。&lt;br&gt;
至于文风的幽默什么的，也在“真实”和“参考文献”面前不值一提了。既然一本书能够告诉你正确的案例为什么正确，错误的案例是怎么一步一步走向bug的，那你为什么还要选别人呢？OSDP书后的Minix代码已经在网上开源了，而OSDP在国内也停售很久了，再往后就是OSC，没了。交大的那本书还没推开，总之OSTEP从现在的视角看也许算是“独孤求败”的典型代表？&lt;br&gt;
OSTEP之后呢？其实你应该看看apue，水课或者别的时候翻翻看看，然后看看Great Ideas in Computer System Design，也是书后多次推荐的好文章。最后书后的minilab很多（也许近两年jyy就是受此启发把OSlab干掉了？），看看源码，再看看xv6-riscv，不想做实验看看源码也行，毕竟不是所有人都想做那样的脏活累活，不是吗？或者如果你真有兴趣可以看看分布式系统相关的内容，不过那部分太难了，我也没学多少，就不说了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>关于6.1810</title>
        <link>https://vzstless.moe/p/%E5%85%B3%E4%BA%8E6.1810/</link>
        <pubDate>Thu, 06 Feb 2025 09:48:12 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E5%85%B3%E4%BA%8E6.1810/</guid>
        <description>&lt;p&gt;终于，从寒假到现在磕磕绊绊算是把6.1810攻克了&lt;/p&gt;
&lt;p&gt;这个课分为几个部分，讲义，课本，xv6本身以及课程。讲义是给你稍微溜一眼这节课要干啥用的，课本的参考价值极高，几乎做实验过一会儿就要翻一下。xv6就不说了，公认的艺术品，功能齐全而且每个调用的路径都极其清晰，哪怕你不按课本瞎改一些部分看报错也是挺享受的。课，emm&amp;hellip;实在话，这个课是真干啊，真hacking啊，估计你讲义和书没看懂的话课程也看不懂。如果你没时间，只看Q&amp;amp;A就行了，代码示例可以跟着讲义自己弄。&lt;/p&gt;
&lt;p&gt;jyy曾说过操作系统是一门增加内功的课，哪怕你的编程能力并不足以支撑你完成这门课程，你以后还会不断地在学习生活中无数次被相同的概念callback。你更习惯于gdb了，你能够解释concurrency和parallelism的区别了，你看汇编代码更快了，你看GFS和MapReduce的时候看到大篇幅的logging想到了ext2+journaling=ext3，你看那些卖虚拟化容器的技术也会感觉“这真没啥”了。&lt;/p&gt;
&lt;p&gt;后来在课程实验快结束的时候你看到了OS-in-1000-lines，一个最初由日文写成的教程，补全了xv6没有告诉你的关于操作系统怎么从零开始的部分。它的代码不如xv6那么优雅，但是能让你真正体验一下什么叫“脏活累活”（点名批评virtio部分）&lt;/p&gt;
&lt;p&gt;实验？lazy-allocation在2023版中被砍掉了，最喜欢的应该是copy-on-write和syscall，一个是让你突然意识到错误处理原来不止是层层包裹的try-catch和Option，还可以用来实现各种花样繁多的新功能。syscall是让你游走在各个文件之间的一个实验，做完之后感觉用gdb比用IDE里头那些被阉割过的玩意儿顺手多了，也让你在RTFSC的时候更习惯于trace了&lt;/p&gt;
&lt;p&gt;总之，挺值得试试的，我对它的评价会远高于SICP和Algorithms。也许以后如果我大四的时候真的实在是闲的没事可能会尝试一下“上不封顶”的CS142？眼前的话，估计只能使用碎片时间增加一下os1000的其他功能了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>商学的死亡</title>
        <link>https://vzstless.moe/p/%E5%95%86%E5%AD%A6%E7%9A%84%E6%AD%BB%E4%BA%A1/</link>
        <pubDate>Mon, 30 Dec 2024 08:08:50 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E5%95%86%E5%AD%A6%E7%9A%84%E6%AD%BB%E4%BA%A1/</guid>
        <description>&lt;p&gt;理论上一个计算机都快学不明白的人不应该对外行的见识发表暴论，但既然学校选择了力推外专业“选修”，不修毕不了业，那我就不先礼后兵了&lt;br&gt;
许多人现如今已经不太看重所谓的MBA或者别的类似的商学学位，认为它们纯纯是二水货，事实证明他们没错。商学的死不是因为商学被什么别的哲学取代了，而是商学被计算机从思维意义上被取代了。这时候你大概率要问：是计算机代替了人力参与了商学相关的事务了吗？是也不是，因为不只是人类意义上的代替，还有思想层面的代替。&lt;br&gt;
几乎所有的管理学相关的思想在计算机哲学中都能找到代替品，而且研究层面上更加极端。流水线优化与对节拍异化为了CPU流水线性能优化，工作中心分配异化为了操作系统中的线程调度优化，公交线路布局异化为了找最长路径，观察次数异化为了单纯的统计题，工序优化异化为了对一个有向图进行拓扑排序，至于剩下的，大概率交给Excel或者大模型都可以完成。从思想和实践层面，计算机科学都直接毙掉了商学。&lt;br&gt;
也许商学的下一步应该把&lt;em&gt;UNIX编程艺术&lt;/em&gt;列为必读书目？但总之不应该是罗宾斯管理学这种老东西了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>生产力与生产关系</title>
        <link>https://vzstless.moe/p/%E7%94%9F%E4%BA%A7%E5%8A%9B%E4%B8%8E%E7%94%9F%E4%BA%A7%E5%85%B3%E7%B3%BB/</link>
        <pubDate>Mon, 16 Dec 2024 21:51:39 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E7%94%9F%E4%BA%A7%E5%8A%9B%E4%B8%8E%E7%94%9F%E4%BA%A7%E5%85%B3%E7%B3%BB/</guid>
        <description>&lt;p&gt;注：以下讨论不涉及C，Python和JavaScript，因为你不用也得用，迟早有一天你会被这仨语言中的一个找上茬儿&lt;/p&gt;
&lt;p&gt;马原课本告诉我们，生产力决定生产关系，生产关系反作用于生产力。我们可以使用这个理论来给计算机行业中的错误思想套公式。现在许多人中流传着Java焦虑，好像Java死了我的工作就彻底寄了，然后经典的中年危机就业焦虑。然而大概率事实是不是Java不行，而是你从始至终就没入行。换语言不会使你干好，反而你长期囿于原先的生产关系而没有意识到自己的生产力本身落后，换了语言，原形毕露，没有论坛可查，自己失去了debug和查找性能瓶颈的能力。类似的还有软件工程。首先，你大概率不是CEO之类的要职，而你的第一个demo做得并不好甚至没做出来，你就觉得现在的软件生产模型不行，想从瀑布模型转变成敏捷模型。然而你没注意到敏捷模型对生产力的要求是达到了一定境界的，你的生产力并不足以满足敏捷模型短期迭代的内在要求，大概率结局是项目流产。&lt;/p&gt;
&lt;p&gt;换一个视角，你应该在简历上写精通XXX语言吗？理论上不应该。这时候就有人问有人就看简历里头的这玩意儿你咋办嘛，我只能说这玩意儿只能反映你接触过这种生产关系，对于你的生产力没有任何反映。你用解释型编程语言大写特写for循环，最后的结果必定是慢的要死。当你想要入坑一个新的编程语言的时候，最好问问自己：&lt;/p&gt;
&lt;p&gt;&lt;br&gt;它和我知道的编程语言有没有本质区别？&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;学会C的人应该接触Python，因为Python是解释型，大量使用库函数的语言而C是编译型，造轮子的语言。Rust和C就没有本质区别，你最开始制作demo的时候对安全没有那样强烈的需求，甚至对cargo一类的项目管理器没什么需求，而你编程经验又不足，你就最好先别弄Rust，而是用C先做一个能跑的东西。&lt;/p&gt;
&lt;p&gt;最后，不妨思考一下这门语言为什么出现。C是UNIX的副产物，C++是为了改进C而产生的，Python脱胎于科学计算，Rust又被Mozilla用于浏览器内核的开发。从这个角度讲也许用Rust重构Chromium比用Rust重构Linux更现实？&lt;/p&gt;
</description>
        </item>
        <item>
        <title>关于一些网络热门课程</title>
        <link>https://vzstless.moe/p/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%BD%91%E7%BB%9C%E7%83%AD%E9%97%A8%E8%AF%BE%E7%A8%8B/</link>
        <pubDate>Sun, 15 Dec 2024 13:38:47 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%BD%91%E7%BB%9C%E7%83%AD%E9%97%A8%E8%AF%BE%E7%A8%8B/</guid>
        <description>&lt;p&gt;事先声明，锐评不代表讨厌，相反，正是因为你有了足够的了解之后你才能知道为啥人家的课程好，我们的为什么烂。我感谢它们，在无数节水课中带我消磨时间，做有趣的事情。&lt;/p&gt;
&lt;h3 id=&#34;sicp&#34;&gt;SICP
&lt;/h3&gt;&lt;p&gt;SICP这个课可就有点儿历史了，上世纪80年代，Abelson和Sussman这俩人用他们编写的教科书改造了MIT的计算机入门课程。它主要使用Lisp的一门方言——MIT Scheme进行编程，讲解关于计算机思维与计算方法的基础知识。现在网上流传的始祖SICP实质上是两个教授去惠普公司进行的讲座，不过内容大同小异就是了。说是基础，但是这个课联同这本书都是极其折磨的。&lt;/p&gt;
&lt;p&gt;首先，Scheme，或者说Lisp系的语言只能写递归不能写迭代。这门课程的起初就在不断地教你如何递归展开。随后便是一些时至今日也在使用的编程语言设计理念的雏形——数据结构，面向对象，流，乃至并发。不要用你学某个现代化程度很高的编程语言的经验简单套用在这里，Lisp的bare metal程度某种意义上不亚于C，许多的现有的知识要先有一层抽象才能转化成Lisp的东西。以及这本书会大量地造轮子。造图片编程语言，造小型SQL，造基于Lisp-Like汇编语言的寄存器机器。对，某种意义上你现有的对于计算机的知识都被颠覆了，这本书告诉你只要有了Lisp你能造出来所有东西！&lt;/p&gt;
&lt;p&gt;当时学的时候我用了先看课再看书的策略，结果发现书上的题目和前头的知识完全就是雕花和切冻肉的关系（笑）。经常有第一题“来，仿照那个加法程序造一个乘法程序”，第二题“来，刚才用迭代写的同学转化成递归来写，刚才用递归的同学用迭代来写！”，第三题“你看，加法和乘法可以抽象成XXX，这个程序怎么写呢？”，第四题又是迭代换递归，递归换迭代，第五题又再抽象一层，抽象到最后还不忘问你一句“嘿，你觉得你的设计真的合理吗？”，绝大多数情况下我做到第三题就破大防去抄答案了。&lt;/p&gt;
&lt;p&gt;第四章和第五章虽说是讲evaluator，SQL和寄存器机器这种显而易见的东西，但是在书里头这玩意儿又被一层又一层抽象了。后来我转念一想“估计这点儿玩意儿我这辈子都用不上了”，就去做了一下“Build your own Lisp”，把第四章和第五章的课程录像看完了就跑了。&lt;/p&gt;
&lt;p&gt;现在想想UCB和MIT把这个课程改成Python，SQL和Lisp真是明智的选择。他们从函数入手而不是递归，大大降低了这门课程的门槛，第四章原来的造轮子变成了摆在眼前的SQL，之于更高层次的抽象则交给了Lisp。Sussman曾经暗讽过这个课程改变是让人做脱离系统的调包侠，但是调包不也是优化程序的一种有效手段吗？何况这个课程的教授方式也大变了，先让你熟悉终端，相关硬件的下载和从网站上获取压缩包。这个知识屏蔽已经到极致了。没有git，没有链接，没有过于繁杂的命令行，总之个人认为这个课程进步了很多。&lt;/p&gt;
&lt;p&gt;有人会问推不推荐学CS61A，我说你要是大佬休闲想学学无所谓。至于老版的SICP和配套的那本书，实在话，还是直接进入历史的故纸堆就好。我读过了，不建议你走同样的路。顺带一提，负责原始版本SICP翻译的HIT IBM俱乐部今日也某种意义上“半死不活”了。&lt;/p&gt;
&lt;h3 id=&#34;algorithms&#34;&gt;Algorithms
&lt;/h3&gt;&lt;p&gt;最初接触这玩意儿的时候是我淘书的时候发现的人民邮电出版社的中译本，“与TAOCP相媲美的神作”，豁，那可得看看咯。结果第一章就看不懂了，作者居然自己搓了个Java标准库用，还得自己配，然后就是极其痛苦的配环境，最后环境没弄成，这本书就吃灰了。&lt;/p&gt;
&lt;p&gt;后来听人说Sedgewick的课比书好，我就去看课，看完就用C++尝试把示例代码重构了。但是有一整章的代码我都重构失败了，就是图算法。这本书绝大多数的代码都依赖于作者自己搓的标准库中的API，这就导致图算法重构的时候源代码毫无参考性，你就只能去诸如OI wiki的地方寻找。我严重怀疑这个所谓的“抽象数据结构”的思想给国内诸如严蔚敏《数据结构》一类的差评如潮的教材开了个坏头。如果我都无法将你的算法思维进行有效的迁移，那你这个课又有什么用呢？&lt;/p&gt;
&lt;p&gt;有！确切来讲是另一种意义上的。这门课会告诉你专业人士是怎么研究算法的。而且这个课很“新”。2007年Sedgewick将Red-Black BST进行了简化，变成了LLRB-BST，2012年，这个研究就被写入了教材。某种意义上这门课程给了你一种“这个算法牛逼吗？我发明的！”的一种震撼。&lt;/p&gt;
&lt;p&gt;于你而言这门课其实只需要看四个地方：开头的并查集优化，快速排序在大量重复关键字下的优化，左斜红黑树和3-Way Trie。这几个算法各有特色，而且有Sedgewick教授的原创成分。相信我，当你看见demo中的红黑树就像被赋予生命了一样自动平衡的时候你会发自内心大吼一句“卧槽”的。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
