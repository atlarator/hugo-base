[{"content":"近期折腾社团报纸总结了好多出版方面的知识，这里先写一点关于字体的。\n最大的头版要用大家有点“刻板印象”很适合用来上头版的字体，或者说这种字不一定耐读，但是看着一定要大气，一定要有那种我出来就是权威的感觉。如果是中文，推荐草檀毛泽东字体，如果是西文可以用Chomsky。\n接下来是文章的标题和内容。这里我一般习惯标题20磅或者15磅而正文10磅，这样在A3纸上能做到至少看起来不费眼睛。这里的字体还是有点讲究的。如果你喜欢那种传统的，容易把人镇住的，能够凸显纸媒的权威性的风格，推荐衬线字体，比如中文的宋体和英文的Times New Roman。但是这两种（或者说这两类）字体如果出现在ppt或者某些更加现代的场合会给人带来不合时宜的年代感和腐旧感。这种需要更加现代字样的场合就需要等线字体了。幸运的是很多等线字体由于本身设计的年代就不太久远，出生便拥有多国字母和CJK的适配，比如MiSans和NotoSans都是不错的。顺带提一嘴，一定要选用开源可商用的字体，诸如微软雅黑和Tahoma之类容易引起纠纷的字体就算了。\n接下来是一些特殊用途。如果你想让你的海报有更多上个二十年的设计感可以使用隶书。如果你想让你的代码更加清楚可以使用Nerdfont或者Cascadia Mono这两个专门为代码特化的字体。如果你喜欢让你的字体像是直接从某个电脑屏幕上抠下来的，可以试试NokiaSans或者Ubuntu font。如果你喜欢那种高冷、扁平而又显得很“平面设计”，苹果的San Francisco绝对不能错过。如果你要做视频字幕，站酷快乐体和得意黑这种活泼而又易读的字体不错。如果你喜欢那种某些电脑零配件厂牌标识的画风，可以试试Modern Warfare、Horyzen之类的仿制开源字体。其实选字体没啥诀窍，最大的诀窍也许是多看身边的东西，觉得设计得好就丢到AI上问问这是什么字体，问完之后下载就行。然后记得避开那些许多人喜欢在QQ聊天记录上使用的艺术字。这些艺术字虽然看着像画，但是笔触之间缺少一种大气，而且不好读。最后要尽量避免大篇幅地使用艺术字。艺术字只适合小块的氛围渲染，但凡使用面积过大就会大大降低整个文件的可读性。\n","date":"2025-09-13T01:27:43Z","permalink":"https://vzstless.moe/p/%E5%B8%AE%E6%88%91%E9%80%89%E4%B8%AA%E5%AD%97%E4%BD%93%E5%90%A7/","title":"“帮我选个字体吧！”"},{"content":"2025年8月27日早间7时16分29秒，我决定开始把Linux From Scratch当成mini hackathon进行学习，终于下午六时左右因grub安装失误前功尽弃。\nLFS被设计在一次会话中完成，其中包含且不限于磁盘分区，grub，硬写系统文件，硬写网卡，持续时间极其长的测试以及循环往复的tar，configure，make，make check，make install。中途还有大量的前后强制依赖——前脚编译出的tcl和expect要用来写gcc的测试，前脚编译出的gcc和binutils后脚就要用来编译后面的工具链，刚才编译的python后面就要用pip装包，以及meson，ninja之类的构建软件，大量重复且有细微差别的活动叠加的后果是毁灭性的，总之一步错步步错。\n这是一个强度远高于之前的两次“系统构建”的活动——前两次中一次只要编译Linux Kernel，准备FHS，把busybox丢进去然后启动qemu，后一次至少你只需要看手册，和其他的装系统有异曲同工之处。但这个不一样，从头开始你都要自己做，工具自己编译，测试自己运行，引导配不好甚至能直接弄坏主系统。总之，不要因为这个工程不涉及写代码就低估了它的工作量。\n虽说这次构建失败了，但是还是收获了不少东西——最重要的就是谁在什么包中，谁依赖于谁，你自己成为了一个人形的包管理器和makefile，一步一步把之前你搜索的“xxx is in which package”给探明，还是很爽的，其次在这个过程中你还可以掌握加快测试和编译的一般方法，度量时间消耗并知晓Linux中你未曾接触过的底层文件和其他环境变量的细节。Linux From Scratch的Scratch之处不只是因为它从bare metal开始，更重要的是它能够带你以手动trace的视角来遍览整个Linux，这是Arch Linux的安装所不能带给你的。\n下一步也许我应该看看grub和启动引导相关的知识了？我在它上栽了无数次，下一次装系统再出问题可就不应该了。\n","date":"2025-08-27T13:34:05Z","permalink":"https://vzstless.moe/p/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%BF%9C%E5%BE%81/","title":"失败的远征"},{"content":"Lecture 1 neuron: a function that records a feature\nconnection: a number of weight\nspread: calculate the function, times the weight, sum the bias and impulse using ReLU(modern way) or Sigmoid(older way)\nDeep Learning itself is just build a huge function.\nLecture 2 Cost: how the whole network recognizes your data\nIt\u0026rsquo;s always easy to find a local minimum in a function\nThe way to calculate the gradient descent is backpropagation\nLecture 3 backpropagation: calculate which bunch of biases \u0026amp; weights change will have a repid decrease on cost function, all of the calculation rely on previous layer of network\nbackpropagation needs a huge bunch of data to train the model, it will be good to divide random shuffled data into mini-batches, and do backpropagation one by one\nLecture 5 large language model: generate next possible word based on previous input(context of human-AI talking)\ntrain, reinforcement learning with human feedback\ntransformers: attention, forward propagation, attention, so on\nfinally choose the most value connects to the context to output\nLecture 6 Attention: vectors communicate with each other to change value\npropagation: vectors passes through network to another attention layer\nweights are ones to train, not data\nembedded layer: a huge matrix for words and their features\nunembedded layer: use the last vector to generate the probability of next possible word to generate\nsoftmax: an algorithm turns vectors into probability distribution, to let largest value close to 1 and smallest value close to 0\nLecture 7 query: what the word care about in the context\nkey: what is provided for queries to check whether it is relevant\nvalue: final result that the word vector should care\nusing softmax to form a normal data, before this, change all non-relevant words a neg-inf weight\nit would be hard to enlarge the context size\nmulti-head is the way GPT scale-out\nLecture 8 perpendicular: same family of meaning, find most vectors that are perpendicular\nlinear, ReLU, linear, MLP are just simplest neural networks\n","date":"2025-08-23T12:20:01+08:00","permalink":"https://vzstless.moe/p/dl-first-taste/","title":"DL First Taste"},{"content":"什么是电脑？ 电脑是一种能够对同级别设备与其他设备进行底层修改或更高层级修改的工具。\n举例来说，电脑可以给电脑装系统，电脑可以给手机刷机，电脑也可以给平板装系统，电脑也可以制作别的设备的启动盘甚至挂载其他的文件系统。\n电脑的最显著特征是什么，或者说电脑的思维是什么？ 电脑在解决任何问题都一定寻求精确解而非近似解。它能够保证所有的问题都可以通过点点点/敲命令行来解决，而非去刻意强调体验的趋同性。绝大多数如今市面上的所谓“电脑替代品”都在追求体验的趋同，这就是典型的近似解而非精确解。\n你对macOS的评价如何？ 它被炒作得太厉害了。\n你在某些视频平台上一旦碰见windows就是故障频发，屏蔽更新，全球事件，碰见macOS就是效率秘籍，转mac大法，碰见Linux就是狗都不用，装什么装。真的，你看见了你也得爆两句粗口。不知道还以为苹果成了他们爹了，怎么就这么能装，觉得自己这么高净值呢，哦高净值人群甚至不care你们这帮人口中的效率工具，你们又如何是好呢？\n最极端的例子就是某些“程序员”，把笔记软件，浏览器，IDE，鼠标控件，平滑窗口控件之类的东西见一个配一个，你就感觉这帮人是不是平常喝奶茶也这么喜欢加小料。看着Arc出来了，配！效率神器！看见Dia出来了，配！效率神器！这种人我就送一句摄影圈常用的话：摄影最重要的不是相机前面的那个头，而是相机后面的那个头。\n身边我也见过许多人觉得macOS的设置过于不直观了，我说那不叫不直观，而是macOS在设计之初就在力求移动端和桌面端操作的“神似”。当一个设置选项不直观的时候，思考一下如果在手机上这样做是不是很直观，你就能理解macOS设计的脑回路了。\n于我而言，虽然我没系统性用过macOS，但是我依然能够指出macOS最大的几处硬伤。\n一是macOS的软件分发模式拥有大量的历史残余。它的软件分发模式更像是本世纪初那种在apple store以光盘形式分发软件的模式而不是开源软件和订阅制软件的基于互联网分发的模式。在本世纪初“信息化”还是一个新名词的时间中，iBook和iWork套件的合购能够做到开袋即食，而今天不是，今天在电脑上人们做着各种各样的事情，人们希望电脑是为未来提供扩展性的工具而非只是注重一时的简便。这一历史残余导致了macOS上包管理器的缺失与App Store的姗姗来迟与功能残缺。\n二是macOS是一个严重依赖GUI的操作系统。这一点甚至比Windows还恶劣。Windows的“难用”是混乱和尾大不掉，而macOS的难用是一种思维定势。你会发现除了Swift，macOS似乎并不注重程序员和持久化用户的需求而是力求让系统变得更华丽，更傻瓜。另一个角度来说，macOS的FS Hierarchy和default shell随着系统的更新一变再变，对于高度关注问题根源的人来说这一点无疑是致命的。\n三是macOS是自由的。FS Hierarchy的事情我说过了，还有更严重的。这里没有lscpu，没有wget，许多你在Linux上耳熟能详信手拈来的命令行工具在这里是不好用甚至是不能用的。对于macOS来说，自动化你应该用我的Apple Script，性能监测你应该用我自己的任务管理器，出问题你不应该用dmesg而是用我的诊断工具，从网上下载东西你应该用我的Safari Toolkit而不是自己抓取或右键下载，甚至玩游戏你也应该先想着我的Apple Arcade而不是自己去什么Steam之类的平台搞。这种“自由”实际上就是损害用户的选择权，比Windows的“有选择权而难用”更加恶劣。\n那你推荐用Linux吗？ 我对某些系统颇有微词只是反驳某些人的吹捧与炒作。Linux确实于我而言是“好用”，但我/我们与市面上绝大多数人的需求是有很大差异的。我们口中的“好用”大概率指的是“可修改性”或“可扩展性”，而绝大多数人口中的“好用”指的是“啥瓜”和“亲民”。这就注定了如果我硬搬我自己的经验给别人会出现高度的不适应。对于Linux我的态度从来不是“推荐”，而是“它是一种工具”。其他两家系统亦然。\n你现在用的是什么组合？ 我现在使用的是ROG Zephyrus G14，Windows 11 24H2作为生活而WSL Debian和WSL NixOS是工作。未来我大概率会转向NixOS系统的MacBook，而将Windows空出来改为AtlasOS之类的系统专门用于生活使用。是的，如果你财力雄厚，双持是个不错的选择，反之，对于许多人中“双持”很好用的“副机”，如果直接推荐给别人作为主力机，大概率会遭到口诛笔伐。\n顺带一提，最好不要和他人骂战什么系统好或不好，说特点，而不是对喷，这对双方的用户都不好。\n","date":"2025-08-20T07:18:16+08:00","permalink":"https://vzstless.moe/p/%E5%85%B3%E4%BA%8E%E7%94%B5%E8%84%91%E7%9A%84%E9%97%AE%E4%B8%8E%E7%AD%94/","title":"关于电脑的问与答"},{"content":"202x年8月1x日，午间时分，距离我回家的火车从济南站开走还有约六个小时。\n我靠，我为什么要选择骑自行车来游历这里的小吃街，我骑了十公里还没骑到，我快饿死了。那里离我所处的位置还有二十公里，我骑不动了，随便找个华香面粥吃一口垫吧垫吧得了。\n按照导航，华香面粥就在十字路口对面的三层小矮楼里。于是，我穿过了这个两个对象红绿灯距离一公里的长十字路口，来到了小矮楼下。\n苍蝇馆子聚集的地方在地面附近总会有泼出来的、晒干的潲水。我把车停在一处潲水不太多的道崖子上，进了小矮楼。\n先进入了右侧门脸房，卖什么济南特色炒饭，不过门口里头只有一个架子，看不见厨房，一个秃瓢的中年男子坐在小马扎上用黑帮大哥看非组织内成员的眼神看着我。很奇怪，他什么话都没说，一般餐馆老板在你进店之后还会问你“吃点啥，看看菜单吧”，他不是。\n“那个\u0026hellip;\u0026hellip;华香面粥在这栋楼的哪儿啊？”\n“顺着中间那个门往上走，二楼。”也许是看我不想吃他们家的菜，这个男人的口气突然变得凶狠了。 我赶紧出去，进了左边的店。\n那个店的招牌上写着“济南拼面”，没有做灯箱，也没有多余的装饰，那个招牌看起来和某些涂色的麻布差不多。店内的空间还是很拥挤的，一条走廊在中间，左侧是三套能分别容纳下四位食客的桌椅，右侧是点菜的窗口。窗口最上方是菜单，中间是一块大玻璃，下方是用类似家中窗台的材质砌成的出餐口。窗口内只有两人，一男一女。老板在收银，老板娘在用汤勺从大锅中舀起中间泛白，周围清澈的汤水往一个蒸笼中浇。看起来像是煮面剩下的汤。原来所谓“原汤化原食”不过如此。\n“你要啥啊？”老板问到。我犹豫了一会儿，算了，我这辈子又有几次能来济南呢，最后走之前吃口济南特产也无妨。店里菜单上只有几种面，左上角是“济南拼面”，21元一笼，示意图就是那个老板娘手中一模一样的蒸笼，中间是香菇片盖着的蒸过的宽面条。中间几个是汤面，标价三十几块钱，不过看样子味道应该也挺公式化的，不要一碗面没两块肉还给我加致死量的花椒，算了算了。\n“那来份济南拼面？”我有些犹豫地说。“看看右上角的配料想要点啥。”老板娘开口了。配料的表单就远没有旁边点面的表单大气，只有两行，逼仄地挤着实际中配料。奇怪的是，这里的配料全是一个字的。诸如“辣”“龙”“吞”“花”“肉”之类的。“我要‘辣’和‘吞’两种配料吧。””停停停，你这样点你最后出的面肯定又酸又辣，你吃不了几口。“老板的语气突然变得没那么成熟了，好像他意识到了我的实际年龄。”哦那你给我来‘肉’和‘吞’吧。“”停停停，那个‘吞’也是肉馅的，你这么点是不是重复了。“老板又打断我。\n不是，你这些配料到底是些什么啊，我只能看出来那个”井“前面有济南和日本两个选择，应该是豆腐。剩下的你写一个字我怎么看得懂啊！算了，一个一个问吧。”我要\u0026hellip;\u0026hellip;“\n我醒了，原来这是一场梦。我没去过济南，网上的搜索结果显示济南没有拼面这个特产，那个聚集好几家苍蝇馆子的小矮楼也没有现实原型。\n","date":"2025-08-16T09:05:33+08:00","permalink":"https://vzstless.moe/p/%E6%B5%8E%E5%8D%97%E6%8B%BC%E9%9D%A2%E5%AF%BB%E5%91%B3%E8%AE%B0/","title":"济南拼面寻味记"},{"content":"什么嘛，Arch Linux哪里劝退了（）\n观前提醒，遇到问题先查手册，本篇专栏仅进行踩坑记录\n从镜像到启动 配置键盘布局和字体，验证引导模式，验证互联网连接，更新系统时间，然后是磁盘分区。\n磁盘分区就是第一个坑，一定要给root和efi划够，哪怕你的swap只有8G也没事，把它俩先照顾好，要不然后面装固件和内核的时候直接失败。\n挂载对应分区（一定不要挂错了！挂错了后面装固件和内核还是莫名失败！）。\n获取中国大陆的镜像站列表，取消清华源和科大源的注释，使用pacstrap安装启动必需的软件包，使用pacman安装vim和dhcpcd（至少要把vim装了，然后dhcpcd在后面网络配置的时候有大用，如果嫌麻烦还要安装NetworkManager）。\nfstab，arch-chroot，设置时区（后面可以通过网络授时把漂移问题解决），本地化，配置主机名，设置root密码（这一部分抄手册即可）。\n安装grub。好，劲爆尾杀。最难看懂的部分来了。这里在稍微skim了一下GRUB的wiki页面之后我在GPT-4o上使用了如下prompt：\n1 2 https://wiki.archlinuxcn.org/wiki/GRUB 现在我在安装archlinux的最后一步了，手册让我安装grub，我现在有/dev/sda1作为/efi，/dev/sda2作为swap，/dev/sda3作为/，接下来我该怎么做呢？ 获得回答后尝试如下的步骤：\n1 2 3 4 5 6 7 8 pacman -S grub efibootmgr mount | grep /efi grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg exit unmount -R /mnt swapoff /dev/sda2 reboot 启动系统完成。\n从启动到桌面 创建非特权账户，准备安装一些自己惯用的命令行工具，安装后发现pacman的所有镜像源都不通了，ping所有的网站（包括1.1.1.1）都不通，着手修复网络问题。\n先尝试了回到安装环境安装，但是arch-chroot命令直接无法获得，启动system-networkd和system-resolved，然后\n1 ln -sf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf 依然不行。大概率不是软件问题，尝试寻找硬件问题。 ip addr 的结果显示我的enp0s3网卡处于DOWN状态，使用 ip link set enp0s3 up ，编辑 /etc/systemd/network/20-wired.network 如下：\n1 2 3 4 5 [Match] Name=enp0s3 [Network] DHCP=yes 然后重启服务：\n1 systemctl restart systemd-networkd 网络恢复\n尝试安装kde桌面，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 更新系统 sudo pacman -Syu # 安装kde plasma sudo pacman -S plasma kde-applications # 安装SDDM用于图形界面的登录 sudo pacman -S sddm sudo systemctl enable sddm # 安装Xorg图形系统 sudo pacman -S xorg-server xorg-apps # 安装显卡驱动（AMD版，勿照抄） sudo pacman -S mesa xf86-video-amdgpu vulkan-radeon # 重启进入kde reboot 进入桌面，但\u0026hellip;\u0026hellip;\n从桌面到环境 锁屏界面输入密码，发现无法正常进入桌面，闪烁一下，然后回到锁屏页面。从头尝试C-M-F{2-6}来进入命令行界面，回到root，建立对应的home文件夹，如下：\n1 2 sudo mkdir -p /home/vzstless sudo chown vzstless:users /home/vzstless 重新启动，进入桌面。先用root身份打开终端，下载sudo，但是sudo在普通用户下无法正常使用，回到root，再设置环境变量：\n1 2 # ~/.bashrc export EDITOR=`which vim` 使用visudo命令，编辑：\n1 vzstless ALL=(ALL:ALL)ALL 再次回到普通用户，正常使用sudo，结束。\n还好，没有想象中那么难，下次试试gentoo（bushi）\n","date":"2025-07-15T19:51:37+08:00","permalink":"https://vzstless.moe/p/arch-linux%E5%AE%89%E8%A3%85%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"Arch Linux安装初体验"},{"content":"一些根据OzaShin Music Channel的讲座汉化版随堂做的笔记\n基础篇 音名，音程，全音，半音\n全全半全全全半的排列直接平移就能得到大调音阶，从C开始即为C大调\n与大调相对的是自然小调，大调的3，6，7降半音即为自然小调\n自然小调的第三音开始，排列就和大调一样了\n平行调：整体移位音阶中的两个音符得到对应的大调/小调（如C大调和A小调）\n同主调：同一个主音的大调和小调（如C大调和C小调）\n顺阶和弦：每三度一个音，共计三个音（如CEG，DFA）称为3和音和弦，四个音同理\n根音到三音的距离为四个半音的为大和弦，三个半音的为小和弦\n将中间的音（三音）降低/升高半音即可改变和弦的大小\n大调的最后一个和弦较为特殊，三个音中间都是三个半音的距离，即五音相比其他和弦降了一个半音的音程（♭5和弦）\n7和maj7：总计距离是十个半音还是十一个半音\n和弦进行：多个和弦改变排列顺序，通常这个顺序中的第一个和弦会给人这个曲子的最初印象（一般用C和Am最多）\nC | Am | Dm G ： 1625\nC | G | Am | Em | F | C | Dm | G ： 卡农\n改变和弦进行中各个和弦之间的间隔也能改变给人的感受\nVoicing：把相邻的两个和弦的同音部分保持一致，只改变不同的那个音，就能减少手在钢琴上的移位距离\n转位：把下位的音转移到上位（CEG-EGC-GCE）\n标注：最低音（C，C/E，C/G）\n只要最低音是根音就算原位和弦，所以可以使用左手弹奏更低位的根音\nbass的音可以直接视作最低音\n一般的曲子多用C这样较为稳定的和弦结束 tonic-dominant-tonic(C-G7-C)\n主-下属-主的组合（C-F-C）\nCadence：T-D-T，T-SD-T，（T-）SD-D-T\n代理和弦：Dm，Em，Am，Bm，根据同音数量分T，D和SD\n同功能的代理和弦互相替代的时候要做到“听着觉得没问题”\n应用篇 基音：音量很大，一般能盖过泛音\n强进行：“泛音能够让人联想到基音”，G-C一类的走向\nC大调中C，E，G为稳定音，而与稳定音紧挨着的音是不稳定的，如果相隔着全音则不易被吸引\n间隔三个全音的音听着会不和谐\nG7：强进行+三全音，最倾向于解决C\n属七和弦：三音和七音一定是 三全音的关系\n偶尔使用平行调的和弦能够增加曲子的色彩\n自然小调缺少导音（实际上是缺少和弦中的三全音）这时候需要将作为导音的音升半音，构成三全音\n和声小调：为了制造导音和三全音把自然小调的第七音提高半音组成的\n在和声小调的基础上把增音程去除变为全音即为旋律小调\n曲中也可以中途转向和声/旋律小调\n属七和弦：形如〇7的和弦\n附属和弦的解决方法：往右数3个或者往左数4个\n注意：F7不能作为附属和弦使用（可能会出现曲调跑偏）\n可以使用度名来标记和弦，如C大调中C为I，Dm为II…Bm为VII\n2-5-1，最初的两个和弦一般用4和音和弦，连续的两个强进行，有很强的终止感\nJ-Pop常用Gm7-C7-Fmaj7的走向（很常见，背下来）\n251也有大调和小调之分，\n附属和弦适合在进入副歌之前用于调动情绪\nsus4：大和弦的三音提升半音构成的\n减和弦：根音和三音，三音和五音之间的距离都是三个半音\n强调经过减和弦使用dim标识，强调从小和弦变换而来使用♭5标识\ndim7：四个音之间相邻的两个音都是三个半音的距离\nm7♭5又称半减七和弦，它的七音并没有进行降半音的处理\n只有在根音以全音移动的进行中才能使用减和弦进行改写，插入第一个和弦距离半音的dim\ndim中含有三全音：与属七和弦省略根音相同\n减和弦一般会给人复杂、阴暗的感受，如果减七和弦带来的情感过于浓重也可以使用减三和弦进行代替\n五度圈：十二点钟方向是C，顺时针转动就上行七个半音\n沿图顺时针旋转度数为对应大调的声调数，逆时针则为降调数\n加升号：从F开始顺时针旋转，加降号：从B开始逆时针旋转\n逆时针移动：纯五度下行=纯四度上行=强进行方向\n减七和弦的构成音相互间隔90度\n增三和弦的三个音在五度图中构成等边三角形\n里和弦：属七和弦的形态，但是不做下行\n里和弦D♭7的所有构成音都和C半音相连\n所有属七和弦都一定有且只有一个对应的里和弦，这两个和弦在五度圈上是一条直线的两端\nF7虽然不能作为附属和弦使用，但是可以作为里和弦下落半音\n下属到主是比属到主更加平稳的下降方法\n属系分数和弦：低音构成强进行的下属和弦\n下属和弦低音无法强进行，可以改成属系分数和弦解决\n另一个弱点是与主和弦相邻半音的音只有一个F\n下属和弦除了改变的那个音之外相较于主和弦太过稳定了，需要改变和弦结构解决，把其中的A改成A♭即可形成下属小和弦\n套句：根音不变，改变上方三，五，七音之间的和弦\n低音以半音或者全音级进的进行：低音线套句\n低音线套句中所有和弦都含有C，可以以C音作为长音结束\n持续低音：固定一组和弦进行低音部\n低音固定在主音：持续低主音，低音固定在属音：持续低属音\n发展篇 sus4分数和弦：既不是大和弦也不是小和弦，因为没有三度音\nsus4的根音和三音之间是五个半音的距离\n分数和弦：转位和弦，Hybrid Chord，Polychord\nHybrid Chord：分子上的和弦的构成因以外的音构成分母\n属系分数和弦属于Hybrid Chord\nF/G拥有sus4的特征音\nsus4系分数和弦：由于分子与分母的错位形成的\n构成方法：分母不动，分子构成下方全音上的大三和弦\n下方全音的和弦作分子用大和弦，反之用小和弦\nTension Chord: add9th和九和弦\n9度：根音高八度再加一个全音\n构成方法：原有的四和弦基础上加一个根音的九度\n小九度：Em7♭9，由于它的九度音和根音是半音的距离\n不含七音的和弦加上9/11/13的时候要有add记号\n和弦的纯五度音对和弦的音响影响也不大，也可以删除\n九和弦中的九音排列在和弦内部能够让声音更饱满\nCmaj13：CEGBA\n避免音（Avoid Note）：距离任一Chord Tone（1/3/5/7）小九度或八度上下的小九度（同音名）的Tension\n要检查是否在Tension和Chord Tone之间有没有小九度\n避免音的形成条件：对Chord Tone形成小九度（或相差八度的小九度）的Tension\n同为Chord Tone的音即使形成小九度也不构成避免音\n对Tension形成小九度（或相差八度的小九度）的Chord Tone不算做避免音\n将和弦的一处音改为避免音的同音，避免音不再存在，但也失去了七和弦的三全音\n但这种方法容易形成转位和弦导致声音变得更奇怪\n小九度变大九度也可以去除避免音（将与避免音冲突的和弦构成音下降半音）\n不改变和弦形态——伴奏不会改变\nAltered Tension：带有升降记号的Tension\n只有升11度和降13度的Altered Tension，否则就是其他的音了\nAltered Tension中的音的升降号和琴键上的升降号没有对应关系\n从Natural9th位置开始，降半音为♭9，升半音为♯9\n大和弦的Natural 11th一定是一个避免音，不能使用\n属七和弦原本音色浑浊，所以加上♭9是可以的\n但即便是属七和弦也禁止纯11度的避免音\n所有的Altered Tension都可以由12小节的蓝调形式与蓝调音阶中的音组合产生\nG7♭9=G7+Bdim7，是一种不稳定的音\nTension Resolve：有紧张感的Tension移动到稳定的和弦音\nOmit：省略与Tension相邻的和弦音\n两个或两个以上的Tension可以复合使用，适用于表达复杂哀伤的情绪\n使用Altered Tension时应该省略和音且排列不要过于紧密\n两个相隔半音的Tension不能同时使用，否则会影响彼此的音响\n7（♭9♯11）有一些不同寻常的性质\nPoly Chord：双层结构，竖着写\n上层结构多为三个和音，下层结构多为四个和音，下层的避免音不能出现在上层中（属和弦除外）\n上层必须含有下层的一个Tension\n上层可以自由转位，下层只有在有低音乐器衬底的情况下转位\n","date":"2025-07-06T15:10:33+08:00","permalink":"https://vzstless.moe/p/%E9%9A%8F%E6%89%8B%E8%AE%B0%E4%B8%8B%E7%9A%84%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86/","title":"随手记下的乐理知识"},{"content":"常看我博客的朋友应该知道，我一直对软件工程这样集中于“生产关系”的学科不屑一顾。一部分原因是校内这些明面上搞“软件工程”的人每天就在研究GUI是不是所谓的“反人类”，然后研究在各种各样的corner case怎么用一个error来告诉用户我们崩了。你要光研究这个那还说啥呢？最后搞计算机的看本专业的所谓“管理学”不行，还得和隔壁的经管系取经，耽误了大量的时间，还把计算机真正该研究的东西变成了“黑箱”。\n然而MIT-6.102不是这样的，它是一个全方位的习惯培养。先告诉你当你单人工作的时候怎么做可维护，问题早出现早治疗的程序，再告诉你团队里的人可以使用什么方法来使得一个更大规模的项目怎么做得更优雅，最后深入语言的实现细节，告诉你什么该用什么不该用。最后还做了一个关于五线谱的小型语言进行这些概念的实践。可以说，软件工程在这里真正变成了一个身体力行的学科，而不是所谓的“生产关系”的嘴炮与空谈，更不是挪移给经管系的高高在上还没什么用的课程。\n另一面，你可以透过这节课对Rust祛魅。把变量设置在最小的可用范围，让绝大多数的变量不可变，注意内存问题，并发的时候善用promise，加入静态类型检查，加入对函数式编程的思想与内容\u0026hellip;\u0026hellip;你可以惊艳于这些“身体力行”的概念在十多年前便经由一门语言实现了，也可以明白那些执迷于所谓“Rust至上”的人为何愚蠢——既然这一切是身体力行的理念，那为什么不自己实践一下呢？\n","date":"2025-05-15T19:45:58+08:00","permalink":"https://vzstless.moe/p/%E6%B5%85%E8%B0%88mit-6.102/","title":"浅谈MIT-6.102"},{"content":"(a + b) % c = ((a % c) + (b % c)) % c\n(a - b) % c = ((a % c) - (b % c)) % c\n(a * b) % c = ((a % c) * (b % c)) % c\nC++中的 std::__gcd(a, b) 可用于计算最大公约数\n裴蜀定理：如果a和b均为整数，则有整数x和y满足ax + by = gcd(a, b)\n二元线性丢番图方程定理：设a, b为整数且gcd(a, b) = d，若d不能整除c，方程没有整数解，如果能够整除，则存在无穷多个整数解\n同余能够在加，减，乘和乘方中保持。\n费马小定理：设n为素数，a是正整数且与n互素，则a ^ (n - 1) 与 1 模n同余\n埃拉托色尼筛：输出素数，筛掉素数的倍数；欧拉筛：让每个数只被自己的最小质因数筛一次\n威尔逊定理：若p为素数，则p可以整除(p - 1)! + 1\nC(n, r) = C(n - 1, r) + C(n - 1, r - 1)\nC(n, r) = (n!) / ( r! (n - r)! )\nLucas定理：C(n, r) 和 C(n mod m, r mod m) * C(n / m, r / m) 模m同余\nCartalan数：C(n) = ΣC(k)C(n - k), C(0) = 1\nC(n) = ((4n - 2) / (n + 1)) * C(n - 1), C(0) = 1\n第一类斯特林数：n个不同元素分配给k个圆排列，圆不能为空\ns(n, k) = s(n - 1, k - 1) + (n - 1) * s(n - 1, k), s(0, 0) = 1, s(k, 0) = 0\n第二类斯特林数：n个不同的球放在k个相同的盒子中，不能有空盒子\nS(n, k) = kS(n - 1, k) + S(n - 1, k - 1), S(0, 0) = 1, S(k, 0) = 0\n","date":"2025-05-04T19:58:00+08:00","permalink":"https://vzstless.moe/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E5%AD%A6%E6%9D%82%E9%A1%B9/","title":"计算机数学杂项"},{"content":"断断续续把OSTEP看完了，最开始看内存虚拟化的时候弃掉了一段时间，后来又捡了回来，因为别的OS textbook太烂了😂\n为什么OSTEP好？说实话，免费反而是最后要提及的有点，除了美国那边课本死贵死贵之外感觉国内的课本基本上要么用二手要么直接下电子版的了。一本Operating System Concepts哪怕是国内的大黑书也要158一本，不过又有多少人会买呢？\n首先一个好的地方是这本书没有过分聚焦到COA或者ICS应当聚焦的部分，直截了当地告诉你操作系统在哪儿，解决了你在COA或者ICS中没碰见的什么问题。OSC和MOS两本书都是要先给你满嘴口水地讲COA和ICS中嚼烂的内容，估计也就学唐XX计组没学明白的人需要这些内容了吧\u0026hellip;\u0026hellip;当然，硬盘的基本原理它还是给你讲了讲，防止你文件系统直接抓瞎（但其实这个部分可以砍掉，既然你第一章推荐了csapp那这部分可以默认讲过）\n其次就是真实。告诉你历史上怎么做的，怎么演化成如今的样子的。几乎所有的示例都会附上对应的在真实世界中能用的API示例代码。这里的一个反例就是MOS，过分地“又臭又长”，而且示例代码还不那么make sense。重点是每章后方的参考文献都给了你阅读指导，告诉你你不仅应该看这本书，还应该再看看这些内容的相关一手消息。\n至于文风的幽默什么的，也在“真实”和“参考文献”面前不值一提了。既然一本书能够告诉你正确的案例为什么正确，错误的案例是怎么一步一步走向bug的，那你为什么还要选别人呢？OSDP书后的Minix代码已经在网上开源了，而OSDP在国内也停售很久了，再往后就是OSC，没了。交大的那本书还没推开，总之OSTEP从现在的视角看也许算是“独孤求败”的典型代表？\nOSTEP之后呢？其实你应该看看apue，水课或者别的时候翻翻看看，然后看看Great Ideas in Computer System Design，也是书后多次推荐的好文章。最后书后的minilab很多（也许近两年jyy就是受此启发把OSlab干掉了？），看看源码，再看看xv6-riscv，不想做实验看看源码也行，毕竟不是所有人都想做那样的脏活累活，不是吗？或者如果你真有兴趣可以看看分布式系统相关的内容，不过那部分太难了，我也没学多少，就不说了。\n","date":"2025-04-28T14:33:15+08:00","permalink":"https://vzstless.moe/p/ostep%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A5%BD/","title":"OSTEP为什么好"},{"content":"最近在pwn.college做不下去的时候试了试UNIX系统编程，在查阅“程序的开始与终止”的资料的时候有评论觉得apue不适合如今的UNIX环境了，推荐了The Linux Programming Interface和Understanding UNIX/Linux Programming（下文简称为UULP）两本书，遂花了半个多月的时间学了后者。我没全学完，但是学了之后我觉得大概率之后我不会大范围涉足这个领域了。\nUULP是一本简要介绍UNIX系统并使用这些系统调用进行UNIX系统工具撰写的书。然而这本书并不好。首先是讲述。看起来书里的图很多，然而当你真的学过一点OS基础你就会觉得这本书在该深入的地方浅尝辄止了，而在讲深入的地方处理的并不好。这本书也有点老了，老到书中的很多示例代码要么缺少 #include 的库要么干脆就是代码片段散落在书的角落或者网站的角落，调试也比想象中的头疼（不过没有OS头疼就是了）。这是一本典型的前AI时代的书，书中有大量的XX-demo示例，但这些示例并没有真正意义上明确这些API的一些特殊行为。同样的代码我为什么不参考apue或者直接给大模型丢一个prompt而要去看你呢？\nOK，骂的有点狠了，说实话，自己造UNIX的轮子还是很难忘的。归根结底我不推荐这本书。如果你真的想了解UNIX系统编程还是需要man page或者大模型。apue不评价，许多人说这本书属于“这辈子也用不上”的范畴，我也没买（同样位列用不上名单的还有编译原理，TAOCP等上古巨神）。UNIX系统编程时至今日在书籍资料方面还是短缺的。apue和TLPI多年之后还是top1参考，而top1下头没有任何的top2。哪怕对于C，top1的K\u0026amp;R下头还有一堆的top2。也许Rust和zig等新兴编程语言在Linux内核的介入能够改变这一切？\n假期的xv6让我对操作系统心驰神往，然而从os1000到UNIX系统编程则某种程度上让我为操作系统相关的脏活累活祛魅了。是时候投入现代编程语言的怀抱了，不能死守着C不走了。\n","date":"2025-03-25T16:40:59+08:00","permalink":"https://vzstless.moe/p/unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%9D%82%E8%B0%88/","title":"UNIX系统编程杂谈"},{"content":"main 函数与程序的启动 main没有原型，启用main需要一个特殊的启动流程\n1 2 3 4 int main(int argc, char *argv[]) { printf(\u0026#34;main is at 0x%lX\\n\u0026#34;, (unsigned long)\u0026amp;main); } 使用c89标准编译后的输出结果与readelf的entry point不同\n使用gdb，发现_start，先跳转到___start，启动_exit和__libc_init，然后跳入main\n执行完程序内所有行为后回到___start\n阅读crt0.S发现内存布局和库函数相关的初始化数据（源实验环境为NetBSD）\n在cc中可以使用-e指定程序的入口函数\n在gdb中查看$rip发现非法的地址访问，产生了段错误，当将这个指定的入口函数使用exit()退出时程序段错误消失\n程序的终止 在C89中没有return的main返回20，而在C99中，这个返回值变成了0\nreturn被视为对一个变量的使用\nexit()退出程序时会使用atexit()，冲刷所有的输出流，关闭所有开放的流，断开使用tmpfile()建立的所有链接，最后调用_exit()系统调用直接关闭线程\natexit()将以相反的顺序寄存所有调用exit()的函数\nexit()也会调用exit_handler.c进行相应的操作\n","date":"2025-03-13T17:07:52+08:00","permalink":"https://vzstless.moe/p/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%A7%8B%E4%B8%8E%E7%BB%88%E6%AD%A2/","title":"程序的开始与终止"},{"content":"Source Code\n看了jyy今年的虚拟内存，有感而发给GPT丢了几个prompt，产生了这些东西：\nmmap mmap() 是一个用于内存映射的syscall，可用于快速分配大段内存空间。\n1 2 void* mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void addr, size_t length); addr为建议的映射地址（一般为NULL），length为映射的字节大小，prot为内存的保护权限，flag为映射类型，fd为映射的文件描述符，offset为文件的起始偏移量。\n其中，length和offset必须是页大小的整数倍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;sys/mman.h\u0026gt; #include\u0026lt;fcntl.h\u0026gt; #include\u0026lt;sys/stat.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { int fd = open(\u0026#34;test.txt\u0026#34;, O_RDWR); if(fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } struct stat st; fstat(fd, \u0026amp;st); char *map = mmap(NULL, st.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(map == MAP_FAILED) { perror(\u0026#34;mmap\u0026#34;); close(fd); return 1; } printf(\u0026#34;file content: %s\\n\u0026#34;, map); strncpy(map, \u0026#34;Hello, mmap!\u0026#34;, 12); munmap(map, st.st_size); close(fd); return 0; } 这里的test.txt必须是一个有原始内容的文件。\n1 Hello as an initial sentence here. 程序运行后，文件内容变为Hello, mmap!initial sentence here.\nmmap()还可以共享内存（匿名映射）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { char *shared_mem = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0); if (shared_mem == MAP_FAILED) { perror(\u0026#34;mmap\u0026#34;); return 1; } strcpy(shared_mem, \u0026#34;Hello, Shared Memory!\u0026#34;); printf(\u0026#34;shared contents: %s\\n\u0026#34;, shared_mem); munmap(shared_mem, 4096); return 0; } vvar和vdso vvar是内核暴露给用户空间的一些只读变量，用于加速某些syscall，可以通过\n1 cat /proc/self/maps | grep vvar 来获取vvar的地址。\nvdso是一个特殊的共享库，提供一些常用的syscall供用户态实现。刚才的grep后改为vdso即可查看vdso的地址空间。某种意义上，vvar和vdso使得Linux不再是纯粹的Monolithic Kernel了\n我们可以尝试禁用vdso来观察前后的syscall速度。\n1 echo 0 | sudo tee /proc/sys/vm/vdso_enabled 在speed.c中有一段代码用于计算时间（然而这个命令在WSL上用不了，WSL的vdso似乎是阉割过的）\npmap pmap可以用于显示进程的内存映射\n1 2 pmap [pid] pmap -x [pid] # 更详细的信息 在pmap_test.c中有一个示范程序，编译后在另一个终端中输入\n1 pmap \u0026lt;pid_of_pmap_test\u0026gt; 进行内存布局观察。\n这种观察终究是有局限性的，于是我尝试扫描整个内存空间。事实证明我低估这件事的工作量了。\n由系统分配的进程 在/proc中使用多次ls之后发现了一些一直不改变的数字，我们使用\n1 2 ps -fp [pid] | more # 这里的一些cmd在没有more的情况下可能显示不全 看看它们分别是什么。别小看这件事情，某种意义上你刨一下发现这是个巨大的历史残留\u0026hellip;\u0026hellip;\npid CMD 1 /sbin/init 2 /init 7 plan9 \u0026ndash;control-socket 7 \u0026ndash;log-level 4 \u0026ndash;server-fd 8 \u0026ndash;pipe-fd 10 \u0026ndash;log-truncate 107 /usr/lib/systemd/systemd-udevd 1219 /sbin/agetty -o -p \u0026ndash; \\u \u0026ndash;noclear \u0026ndash;keep-baud - 115200,38400,9600 vt220 200 snapfuse /var/lib/snapd/snaps/snapd_23545.snap /snap/snapd/23545 -oro,nodev,allow_other,suid 这个plan9出来的时候没绷住，感觉像是一位已经死了的故人突然复活了一样\n遍历整个地址空间 在segment_full.c中我尝试遍历整个64位地址空间，这个程序花了我整整十分钟，然而结果全是invalid。\n询问后GPT建议我只扫描实际映射的内存区域：\n1 2 3 4 5 6 FILE *maps = fopen(\u0026#34;/proc/self/maps\u0026#34;, \u0026#34;r\u0026#34;); char line[256]; while (fgets(line, sizeof(line), maps)) { printf(\u0026#34;%s\u0026#34;, line); } fclose(maps); 不行，这时候的扫描结果依然全是invalid。\n接下来就是未知领域了，我先尝试在root下运行这个程序，还是不行。主要问题在于我们不能使用并发进行提速，否则大概率会破坏映射。gpt给了另一个建议，使用mincore()进行查找。\n然而这个程序甚至把我的gdb干崩了\u0026hellip;\u0026hellip;\n在segment_part.c中你可以找到这段程序。\n话说回来，我们看看mincore()\n1 int mincore(void *addr, size_t length, unsigned char *vec); addr为查询的起始地址，必须是页对齐的地址\nlength为要查询的内存大小\nvec为输出缓冲区\n这个syscall不会触发page fault，也不会分配新的物理页\n说实话，虽然好几个程序都运行失败了，但是虚拟内存还是蛮好玩的:trollface:\n","date":"2025-03-07T08:42:42+08:00","permalink":"https://vzstless.moe/p/%E7%8E%A9%E8%BD%AC%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","title":"玩转虚拟内存"},{"content":"pwn.college 先使用ssh-keygen进行key的建立：\n1 ssh-keygen -f key -N \u0026#39;\u0026#39; 然后将公钥复制到pwn.college中 想要链接dojo时使用：\n1 ssh -i key hacker@dojo.pwn.college 从一次git push失败说起 2月13日，我的git莫名其妙push不到远端了，尝试排查问题，先使用了ping，没发现任何问题，后使用ssh -T git@github.com，不行，尝试重启wsl --shutdown，不行，尝试查看GitHub是否今天有服务中断，进入 https://www.githubstatus.com/ 进行查看，一切正常，尝试unset掉proxy，未解决，进行nslookup，未解决，查看代理端口发现代理端口从1085更改至1087，重新设置git config，解决\n","date":"2025-02-13T17:11:02+08:00","permalink":"https://vzstless.moe/p/ssh%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%9D%82%E9%A1%B9/","title":"ssh与网络杂项"},{"content":"终于，从寒假到现在磕磕绊绊算是把6.1810攻克了\n这个课分为几个部分，讲义，课本，xv6本身以及课程。讲义是给你稍微溜一眼这节课要干啥用的，课本的参考价值极高，几乎做实验过一会儿就要翻一下。xv6就不说了，公认的艺术品，功能齐全而且每个调用的路径都极其清晰，哪怕你不按课本瞎改一些部分看报错也是挺享受的。课，emm\u0026hellip;实在话，这个课是真干啊，真hacking啊，估计你讲义和书没看懂的话课程也看不懂。如果你没时间，只看Q\u0026amp;A就行了，代码示例可以跟着讲义自己弄。\njyy曾说过操作系统是一门增加内功的课，哪怕你的编程能力并不足以支撑你完成这门课程，你以后还会不断地在学习生活中无数次被相同的概念callback。你更习惯于gdb了，你能够解释concurrency和parallelism的区别了，你看汇编代码更快了，你看GFS和MapReduce的时候看到大篇幅的logging想到了ext2+journaling=ext3，你看那些卖虚拟化容器的技术也会感觉“这真没啥”了。\n后来在课程实验快结束的时候你看到了OS-in-1000-lines，一个最初由日文写成的教程，补全了xv6没有告诉你的关于操作系统怎么从零开始的部分。它的代码不如xv6那么优雅，但是能让你真正体验一下什么叫“脏活累活”（点名批评virtio部分）\n实验？lazy-allocation在2023版中被砍掉了，最喜欢的应该是copy-on-write和syscall，一个是让你突然意识到错误处理原来不止是层层包裹的try-catch和Option，还可以用来实现各种花样繁多的新功能。syscall是让你游走在各个文件之间的一个实验，做完之后感觉用gdb比用IDE里头那些被阉割过的玩意儿顺手多了，也让你在RTFSC的时候更习惯于trace了\n总之，挺值得试试的，我对它的评价会远高于SICP和Algorithms。也许以后如果我大四的时候真的实在是闲的没事可能会尝试一下“上不封顶”的CS142？眼前的话，估计只能使用碎片时间增加一下os1000的其他功能了。\n","date":"2025-02-06T09:48:12+08:00","permalink":"https://vzstless.moe/p/%E5%85%B3%E4%BA%8E6.1810/","title":"关于6.1810"},{"content":"龙芯杯介绍 龙芯杯：CPU设计相关\n第9届\nloongarch类似于RISC-V\n初赛：CPU+L1 cache\n决赛配SoC外设和PMON BIOS\n团队赛发平台\n三月开始报名，八月上旬交初赛作品，八月中旬提交决赛作品\n个人赛名额不限\n按照官方接口实现指令集的正确性与性能，完全客观评分\n决赛：启动相关设施\n半天时间接一条指令\n三等奖以上可进行加分\n2022年第一次接触loongarch架构\n个人赛经验分享 个人赛：决赛100分，基准测试运行70%，编程任务30%\n纯粹的性能比拼 比较运行时间，只要运行时间足够短就行\n运行时间=指令数/每秒指令数\n提升IPC的思路： 普通运算CPI=1，乘法CPI=2，访存CPI=3\n条件分支需要分支预测相关\nCPU微架构设计决定了IPC\n编码技巧，流水级数的划分，布线质量和资源占用数\n设计简单，频率反而高\nFPGA芯片的体质可能不同\n有些部件的加入可能反而使性能下降\n面向测试程序进行设计\n内存复制，矩阵乘法，哈希算法\n观察发现程序1访存极其规律，矩阵乘法也比较规律，第三个程序访存就具有很大的随机性了\n乱序多发射性价比不高，提升主频是有效的\n程序2可能需要stride进行预取\n大量的时间花在了访存上，数据预取\n使用1bit BHT 或者 BTB也可\n有可挖掘的指令并行性，但是性价比不高\n实现指令cache很有必要\n实现分支预测器，写缓冲器的性价比较高\n实现数据预测器、数据cache和乱序多发射的性价比较低，不如考虑提升频率\n提升频率？在vivado的PLL IP中设置\n但是由于触发器有setup time，在下一个数据到来之前数据必须保持稳定的时间\nWNS：时钟周期与满足所需约束的差值，当WNS \u0026lt; 0时电路时序可能无法保证\n超频：只能说是最后的手段\n使用时序分析工具\nimplementation -\u0026gt; Report timing summary\n列出路径，理解是从什么部件到什么部件的关键路径\n使用vivado对路径进行画图\n更合理地划分流水等级\n选择在哪里切一刀进行划分\n数据cache：IPC↑，BRAM资源占用↑\n数据预取：IPC↑，逻辑复杂，不利于超频\n乱序多发射：IPC↑，逻辑变复杂，不利于超频\n编码技巧：vivado user guide\n使用更加激进的综合实现策略，最终还能带来10-20MHz的性能提升\n个人赛的优化思路已经被挖的差不多了\n团队赛经验分享 特等奖：性能/功能重大创新\n一等奖：Linux+性能优秀\n二等奖：能跑操作系统\n三等奖：能跑测试程序\nCPU：超大工作量，SoC：大工作量，系统软件：中等工作量\n正确性保证，性能调优，丰富功能\n比较推荐Chisel和Spinal，面向功能写代码，上手难度低\n基于其它语言的HDL扩展玩具性质较强，不太方便使用\n乱序执行，多级流水线，分支预测，cache，TLB，MMU\n参考往年开源方案，参考香山处理器微架构文档\nCPU实现要点：简化设计\n前端和后端实现，模块化实现\n尽量保证不同模块之间是黑盒\n分支预测和cache可以和cpu分开开发\n浮点指令集等到启动Linux之后再做\n参考书目：\n计算机体系结构教材，超标量处理器设计，CPU设计实战\n流程： 开学前4人现在chiplab完成CPU设计实战的实验部分\n开学后两人完成CPU设计，完成乱序和超标量部分\n一人完成SoC，使用现成的CPU做\n一人完成分支预测，cache和系统适配等\n官方的trace太弱，很多问题测不出来\n三步走：确保在最小的SoC上运行Linux\n做出自己的SoC，支持更多外设\n丰富系统软件\n只有CPU强制要求自行实现\nSoC：使用vivado block design\n外设控制器，重视扩展I/O口\n软件系统部署： PMON/u-boot，片上ROM/片外flash\n只需要加载Linux内核elf即可\nLinux内核：载入内存，正确配置设备树和驱动程序\n根文件系统：busybox，buildroot，移植libc等运行库\n应用软件：编译开源代码\n推荐方向：物联网，网络应用，游戏应用\nAI应用，发行版Linux中前者算力受限后者板载内存受限 24年特等奖的GUI界面\n","date":"2025-01-25T11:45:07+08:00","permalink":"https://vzstless.moe/p/%E9%BE%99%E8%8A%AF%E6%9D%AF%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/","title":"龙芯杯讲座笔记"},{"content":"理论上一个计算机都快学不明白的人不应该对外行的见识发表暴论，但既然学校选择了力推外专业“选修”，不修毕不了业，那我就不先礼后兵了\n许多人现如今已经不太看重所谓的MBA或者别的类似的商学学位，认为它们纯纯是二水货，事实证明他们没错。商学的死不是因为商学被什么别的哲学取代了，而是商学被计算机从思维意义上被取代了。这时候你大概率要问：是计算机代替了人力参与了商学相关的事务了吗？是也不是，因为不只是人类意义上的代替，还有思想层面的代替。\n几乎所有的管理学相关的思想在计算机哲学中都能找到代替品，而且研究层面上更加极端。流水线优化与对节拍异化为了CPU流水线性能优化，工作中心分配异化为了操作系统中的线程调度优化，公交线路布局异化为了找最长路径，观察次数异化为了单纯的统计题，工序优化异化为了对一个有向图进行拓扑排序，至于剩下的，大概率交给Excel或者大模型都可以完成。从思想和实践层面，计算机科学都直接毙掉了商学。\n也许商学的下一步应该把UNIX编程艺术列为必读书目？但总之不应该是罗宾斯管理学这种老东西了。\n","date":"2024-12-30T08:08:50+08:00","permalink":"https://vzstless.moe/p/%E5%95%86%E5%AD%A6%E7%9A%84%E6%AD%BB%E4%BA%A1/","title":"商学的死亡"},{"content":"（一篇在分享会上的稿件的留档）\n引子 Mathematica的基础语法三句话就能解决：\n1.内置函数的每个单词以大写字母开头。\n2.函数用[]传参。\n3.List用{}包围。\n1 2 {1，2，3} {{1，2}，{3，4}} 由于Mathematica的语法糖实在是太多太多太多了，所以这里我尽量使用最基础的语法。可能看着不好看，但是保看懂。（Mathematica不带转义md的功能，所以这个文档的代码显示并不好）\n这个问题来自于10年前百度贴吧Mathematica吧的一个帖子，我们尝试复现一下这个问题。\n生成方程并提取方程的解 系数为±1的二次方程长这样：\n1 2 3 4 In[]:=x^Range[0, 2] . # == 0 \u0026amp; /@ Tuples[{-1, 1}, 3] Out[]={-1 - x - x^2 == 0, -1 - x + x^2 == 0, -1 + x - x^2 == 0, -1 + x + x^2 == 0, 1 - x - x^2 == 0, 1 - x + x^2 == 0, 1 + x - x^2 == 0, 1 + x + x^2 == 0} In和Out代表运行语句和运行结果，不用管它们。你只需要看Out后头生成的东西。这里使用的生成方法是穷举-1和1的n+1元组合与x的从0到n次幂点乘等于0。但是这个方法有点儿慢，用代数数可以快点儿。\n1 2 In[]:=AlgebraicNumber[x, {1, -1, 1, 1, -1}] == 0 Out[]=1 - x + x^2 + x^3 - x^4 == 0 严格来说，Mathematica内部的代数数函数是有点儿问题的，因为它允许系数取实数范围，不过这不重要，重点是我们生成了一个符合题干要求的方程，而且这个语法比上头那个好使一万倍。\n接下来，解方程。先想到的肯定是NSolve，Solve用于求某个方程的解析解，NSolve用于求某个方程的数值解。\n1 2 In[]:=NSolve[AlgebraicNumber[x, {1, -1, 1}] == 0, x] Out[]={{x -\u0026gt; 0.5 - 0.866025 I}, {x -\u0026gt; 0.5 + 0.866025 I}} 画图肯定不能指望这玩意儿画，所以要想办法提取出来解。用TreeForm分析层次（或者瞪眼法也行）可知，第一层是包含两个List的List，第二层是包含每个解的List，第三层是-\u0026gt;（Mathematica中称为Rule）。[[]]可以用来提取解，而ReIm函数可以将解的实部和虚部生成一个List返回。\n1 2 In[]:=ReIm[NSolve[AlgebraicNumber[x, {1, -1, 1}] == 0, x][[All, 1, 2]]] Out[]={{0.5, -0.866025}, {0.5, 0.866025}} 尝试画个图先\n1 In[]:=ListPlot[ReIm[NSolve[AlgebraicNumber[x, {#1, #2, #3, #4, #5, #6, #7, #8, #9, #10}] ==0, x][[All, 1, 2]]] \u0026amp; @@@ Tuples[{-1, 1}, 10]] 其中ListPlot为绘制散点图，@@@用于替换表达式的一级标头（TreeForm的第一层），#和\u0026amp;为纯函数的自变量和结尾标识，这个图长这样：\n然后你发现你的电脑有点儿卡了。\n效率问题 我们循规蹈矩一点儿，至少还有两招能用。\n1.小数比整数快。\n如果你在Mathematica计算1/2，结果会返回二分之一。同理的，解方程也会如此。\n1 2 3 4 In[]:=Solve[2 x^2 + 3 x + 4 == 0, x] Out[]={{x -\u0026gt; 1/4 (-3 - I Sqrt[23])}, {x -\u0026gt; 1/4 (-3 + I Sqrt[23])}} In[]:=Solve[2.0 x^2 + 3.0 x + 4.0 == 0.0, x] Out[]={{x -\u0026gt; -0.75 - 1.19896 I}, {x -\u0026gt; -0.75 + 1.19896 I}} Mathematica中整数的精度不是1，而是无穷。我们显然不需要那么高的精度，用机器精度足以完成任务了。\n2.专用函数比通用函数快。\nSolve和NSolve的求解原理是求f(x)=0的反函数，对于超越方程来说，没办法，只能是它。但是我们今天的主角是多项式，可以有更快的方法。\n1 2 In[]:= NRoots[AlgebraicNumber[x, {1, -1, 1}] == 0, x] Out[]=x == 0.5 - 0.866025 I || x == 0.5 + 0.866025 I NRoots给出一个多项式方程的数值近似解。\n验证一下NRoots和NSolve哪个更快,求解1000个方程比较一下。\n1 2 3 4 In[]:=AbsoluteTiming[Do[List@@NRoots[AlgebraicNumber[x, {4., 3., 2., 1.}] == 0, x][[All, 2]], {1000}]] Out[]={0.0411889, Null} In[]:=AbsoluteTiming[Do[List@@NRoots[AlgebraicNumber[x, {4., 3., 2., 1.}] == 0, x][[All, 1, 2]], {1000}]] Out[]={1.1734, Null} 一个0.04秒，一个1.17秒，差距相当明显。\n如法炮制，我们观察一下结构（或者使用TreeForm），第一层是Or，也就是||，第二层是用Equal（==）连接的x与对应解。开始替换。\n1 2 In[]:=ReIm[List @@ NRoots[AlgebraicNumber[x, {1, -1, 1}] == 0, x][[All, 2]]] Out[]={{0.5, -0.866025}, {0.5, 0.866025}} 理论上，只要把这玩意儿封装成函数，画个散点图这事儿就结束了。但是还是别这样了，我试过了，13次方程，用了65秒，全程内存占用没下700M。\n师夷长技以制夷 思考一个问题：我真的需要求出所有的方程的解吗？\nx^2+x+1==0和-x^2-x-1==0的解是一模一样的，之前生成的这些方程中有一半是求解了也没用的。所以我们只需要考虑最高次系数为正1的情形。\n1 f[list_]:=List@@NRoots[AlgebraicNumber[x,Append[list,1]]==0,x][[All,2]] Append用于在列表末尾插入值。\n再试试？\n1 2 In[]:=AbsoluteTiming[f /@ Tuples[{-1, 1}, 13]] Out[]={6.16429,{...}} 现在我们倒是求出来了13次方程的所有解，然而吧主的最终图像中求解了19次方程，这个时间是6.16秒的5个数量级，而且这还没计算画图时间。显然，这是我们承受不起的。\n然后，我们发现了一个悲哀的事实：\nMathematica中NRoots的求解效率比MATLAB中的roots低了一个数量级！\n幸运的是，MATLAB可以随意篡改函数的源代码，一句话就可以一睹这个函数的芳容：\n1 edit(which(\u0026#34;roots.m\u0026#34;)) 举例说明一下原理：\n已知三次多项式方程： $$ a_3x^3+a_2x^2+a_1x+a_0=0 $$ 构造矩阵： $$ A=\\begin{bmatrix} -\\frac{a_2}{a_3} \u0026 -\\frac{a_1}{a_3} \u0026-\\frac{a_0}{a_3} \\\\ 1 \u0026 0 \u0026 0\\\\ 0 \u0026 1 \u0026 0 \\end{bmatrix} $$ 解为： $$ x=\\begin{bmatrix} x_1\\\\x_2\\\\x_3 \\end{bmatrix} $$ 对解有Ax=λx，则有方程： $$ \\begin{matrix} -\\frac{a_2}{a_3}x_1-\\frac{a_1}{a_3}x_2-\\frac{a_0}{a_3}x_3=\\lambda x_1\\\\ x_1=\\lambda x_2\\\\ x_2=\\lambda x_3 \\end{matrix} $$ 代入原方程就可以把求解方程的解转化为求解矩阵的特征值，以上原理对n次方程依然成立。\n明白了原理就可以自己写一个类似的，不过我们只要系数±1的情况所以不必完全照抄。\n1 2 3 4 modifiedroots[c_List]:=Module[{a},a=DiagonalMatrix[ConstantArray[1.,Length[c]-1],-1]; a[[1]]=-c; Eigenvalues[a] ]; （顺带一提Mathematica里头用个局部变量麻烦得可怕，同样可怕的是字符串拼接，不过今天的内容不涉及）\n算14次方程的时候这个函数竟然只用了1.23秒！（我们一共计算了2^14个方程）\n准备绘图。不过我们换个方式。前头的两个散点图太难看了，我们改成密度图。\n首先对点的分布进行统计。既然效率提高了就直接上18次方程。\n1 2 3 4 5 In[]:=n = 18; data = ReIm[Flatten[modifiedroots /@ Tuples[{-1, 1}, n]]]; counts = BinCounts[data, {-2, 2, 4./601}, {-2., 2., 4./601}]; Sort[Flatten[counts]] Out[]=(*这里的输出有多于36万个元素，不进行列举*) 将统计结果转化为平面直角坐标系中的对应点的灰度：\n1 ArrayPlot[counts] 大概长这样：\n合理的篡改 这个图并不好看，甚至于说没有观察价值。\n回到数据观察，我们发现这个数据集中有一大半的0和一大半1000以上的数据。光学的衍射实验中也有类似的情况，称为衍射主极大。我们平常在书上看到的衍射图样都是被处理过的，实际上，真正的衍射实验中中间的条纹光强是远高于边缘的小条纹的。\n1 2 In[]:=Sort[Flatten[UnitStep[300 - counts]*counts]] Out[]=(*这里的输出有多于36万个元素，不进行列举*) UnitStep在x＜0时取0，x≥0时取1。\n再画一下图：\n1 ArrayPlot[UnitStep[300 - counts]*counts] 改个颜色：\n1 ArrayPlot[UnitStep[300 - counts]*counts,ColorFunction-\u0026gt;\u0026#34;AvocadoColor\u0026#34;] 大功告成！\n更严重的问题 到现在为止，题干的问题就算解决了，我们得到了一个环，还是带刺的。\n那如果是24次方程呢？\n时间不是最大的问题，最大的问题在内存上，反正我是不敢在我的小家伙上跑这玩意儿了。问题在哪儿呢？肯定不在那2的24次方个±1上，那就只可能在遍历上了。Mathematica在遍历的时候是不对已遍历的数据进行处理的，也就是说，连带着已经遍历完的数据，原始数据，正在遍历的数据和还没遍历的数据一起堆在了内存里，这就很可怕了。\n想想办法，生成一个，计算一个，扔掉一个。\n无论怎么生成，我们最终要的是1和-1组成的序列，所以我们可以使用二进制生成。\n1 gene[num_,n_]:=(-1.)^IntegerDigits[num,2,n]; 这个函数生成-1与长为n的二进制序列的每一位的幂的List。\n但是如果用这个的话BinCounts又用不了了，因为它一次只产生一组方程的解。\n所以又要重写计数函数。\n至于这部分，还是参考原帖吧，放弃复原了……\n尾声 实在话，讲Mathematica是不那么简单的事儿，因为它的语法糖和函数嵌套实在是多得丧心病狂。自己用还行，一讲就寄了。最早准备讲讲Julia，结果我用了半天发现这玩意儿连包都不成气候那还用个锤子。我宁愿下次讲MATLAB，Python因为肚子里头没啥关于Python的油水一开始就没考虑。\n至于今天讲的内容，如果你看不懂编程语言也没关系，总之就是探索了如何高效地解大量的方程并将它们的解可视化。\n大概率如果下次讨论交流不会整这么大的花活儿了，毕竟肚子里头的油水也不是取之不尽用之不竭的，还得再添才是。\n参考链接：\nhttps://jump2.bdimg.com/p/3622255435?pn=1\n","date":"2024-12-18T21:38:49+08:00","permalink":"https://vzstless.moe/p/%E7%B3%BB%E6%95%B0%E4%B8%BA1%E7%9A%84n%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%A0%B9%E5%9C%A8%E5%A4%8D%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%88%86%E5%B8%83/","title":"系数为±1的n次方程根在复平面的分布"},{"content":"注：以下讨论不涉及C，Python和JavaScript，因为你不用也得用，迟早有一天你会被这仨语言中的一个找上茬儿\n马原课本告诉我们，生产力决定生产关系，生产关系反作用于生产力。我们可以使用这个理论来给计算机行业中的错误思想套公式。现在许多人中流传着Java焦虑，好像Java死了我的工作就彻底寄了，然后经典的中年危机就业焦虑。然而大概率事实是不是Java不行，而是你从始至终就没入行。换语言不会使你干好，反而你长期囿于原先的生产关系而没有意识到自己的生产力本身落后，换了语言，原形毕露，没有论坛可查，自己失去了debug和查找性能瓶颈的能力。类似的还有软件工程。首先，你大概率不是CEO之类的要职，而你的第一个demo做得并不好甚至没做出来，你就觉得现在的软件生产模型不行，想从瀑布模型转变成敏捷模型。然而你没注意到敏捷模型对生产力的要求是达到了一定境界的，你的生产力并不足以满足敏捷模型短期迭代的内在要求，大概率结局是项目流产。\n换一个视角，你应该在简历上写精通XXX语言吗？理论上不应该。这时候就有人问有人就看简历里头的这玩意儿你咋办嘛，我只能说这玩意儿只能反映你接触过这种生产关系，对于你的生产力没有任何反映。你用解释型编程语言大写特写for循环，最后的结果必定是慢的要死。当你想要入坑一个新的编程语言的时候，最好问问自己：\n它和我知道的编程语言有没有本质区别？\n学会C的人应该接触Python，因为Python是解释型，大量使用库函数的语言而C是编译型，造轮子的语言。Rust和C就没有本质区别，你最开始制作demo的时候对安全没有那样强烈的需求，甚至对cargo一类的项目管理器没什么需求，而你编程经验又不足，你就最好先别弄Rust，而是用C先做一个能跑的东西。\n最后，不妨思考一下这门语言为什么出现。C是UNIX的副产物，C++是为了改进C而产生的，Python脱胎于科学计算，Rust又被Mozilla用于浏览器内核的开发。从这个角度讲也许用Rust重构Chromium比用Rust重构Linux更现实？\n","date":"2024-12-16T21:51:39+08:00","permalink":"https://vzstless.moe/p/%E7%94%9F%E4%BA%A7%E5%8A%9B%E4%B8%8E%E7%94%9F%E4%BA%A7%E5%85%B3%E7%B3%BB/","title":"生产力与生产关系"},{"content":"事先声明，锐评不代表讨厌，相反，正是因为你有了足够的了解之后你才能知道为啥人家的课程好，我们的为什么烂。我感谢它们，在无数节水课中带我消磨时间，做有趣的事情。\nSICP SICP这个课可就有点儿历史了，上世纪80年代，Abelson和Sussman这俩人用他们编写的教科书改造了MIT的计算机入门课程。它主要使用Lisp的一门方言——MIT Scheme进行编程，讲解关于计算机思维与计算方法的基础知识。现在网上流传的始祖SICP实质上是两个教授去惠普公司进行的讲座，不过内容大同小异就是了。说是基础，但是这个课联同这本书都是极其折磨的。\n首先，Scheme，或者说Lisp系的语言只能写递归不能写迭代。这门课程的起初就在不断地教你如何递归展开。随后便是一些时至今日也在使用的编程语言设计理念的雏形——数据结构，面向对象，流，乃至并发。不要用你学某个现代化程度很高的编程语言的经验简单套用在这里，Lisp的bare metal程度某种意义上不亚于C，许多的现有的知识要先有一层抽象才能转化成Lisp的东西。以及这本书会大量地造轮子。造图片编程语言，造小型SQL，造基于Lisp-Like汇编语言的寄存器机器。对，某种意义上你现有的对于计算机的知识都被颠覆了，这本书告诉你只要有了Lisp你能造出来所有东西！\n当时学的时候我用了先看课再看书的策略，结果发现书上的题目和前头的知识完全就是雕花和切冻肉的关系（笑）。经常有第一题“来，仿照那个加法程序造一个乘法程序”，第二题“来，刚才用迭代写的同学转化成递归来写，刚才用递归的同学用迭代来写！”，第三题“你看，加法和乘法可以抽象成XXX，这个程序怎么写呢？”，第四题又是迭代换递归，递归换迭代，第五题又再抽象一层，抽象到最后还不忘问你一句“嘿，你觉得你的设计真的合理吗？”，绝大多数情况下我做到第三题就破大防去抄答案了。\n第四章和第五章虽说是讲evaluator，SQL和寄存器机器这种显而易见的东西，但是在书里头这玩意儿又被一层又一层抽象了。后来我转念一想“估计这点儿玩意儿我这辈子都用不上了”，就去做了一下“Build your own Lisp”，把第四章和第五章的课程录像看完了就跑了。\n现在想想UCB和MIT把这个课程改成Python，SQL和Lisp真是明智的选择。他们从函数入手而不是递归，大大降低了这门课程的门槛，第四章原来的造轮子变成了摆在眼前的SQL，之于更高层次的抽象则交给了Lisp。Sussman曾经暗讽过这个课程改变是让人做脱离系统的调包侠，但是调包不也是优化程序的一种有效手段吗？何况这个课程的教授方式也大变了，先让你熟悉终端，相关硬件的下载和从网站上获取压缩包。这个知识屏蔽已经到极致了。没有git，没有链接，没有过于繁杂的命令行，总之个人认为这个课程进步了很多。\n有人会问推不推荐学CS61A，我说你要是大佬休闲想学学无所谓。至于老版的SICP和配套的那本书，实在话，还是直接进入历史的故纸堆就好。我读过了，不建议你走同样的路。顺带一提，负责原始版本SICP翻译的HIT IBM俱乐部今日也某种意义上“半死不活”了。\nAlgorithms 最初接触这玩意儿的时候是我淘书的时候发现的人民邮电出版社的中译本，“与TAOCP相媲美的神作”，豁，那可得看看咯。结果第一章就看不懂了，作者居然自己搓了个Java标准库用，还得自己配，然后就是极其痛苦的配环境，最后环境没弄成，这本书就吃灰了。\n后来听人说Sedgewick的课比书好，我就去看课，看完就用C++尝试把示例代码重构了。但是有一整章的代码我都重构失败了，就是图算法。这本书绝大多数的代码都依赖于作者自己搓的标准库中的API，这就导致图算法重构的时候源代码毫无参考性，你就只能去诸如OI wiki的地方寻找。我严重怀疑这个所谓的“抽象数据结构”的思想给国内诸如严蔚敏《数据结构》一类的差评如潮的教材开了个坏头。如果我都无法将你的算法思维进行有效的迁移，那你这个课又有什么用呢？\n有！确切来讲是另一种意义上的。这门课会告诉你专业人士是怎么研究算法的。而且这个课很“新”。2007年Sedgewick将Red-Black BST进行了简化，变成了LLRB-BST，2012年，这个研究就被写入了教材。某种意义上这门课程给了你一种“这个算法牛逼吗？我发明的！”的一种震撼。\n于你而言这门课其实只需要看四个地方：开头的并查集优化，快速排序在大量重复关键字下的优化，左斜红黑树和3-Way Trie。这几个算法各有特色，而且有Sedgewick教授的原创成分。相信我，当你看见demo中的红黑树就像被赋予生命了一样自动平衡的时候你会发自内心大吼一句“卧槽”的。\n","date":"2024-12-15T13:38:47+08:00","permalink":"https://vzstless.moe/p/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%BD%91%E7%BB%9C%E7%83%AD%E9%97%A8%E8%AF%BE%E7%A8%8B/","title":"关于一些网络热门课程"},{"content":"单周期处理器（LA版本） 延迟槽：曾几何时它很好，然而它非但无法解决延迟造成的流水线阻塞问题，而且会使微结构的设计复杂化，而且编译器并不能总是提取出有效指令填入流水线导致流水线中出现过量空指令，影响流水线性能\n支持远距离跳转的指令集可以更好减少由于代码体积增大而产生的效率降低问题\n跳转后还要从寄存器中获得对应的地址，故称间接跳转，link用于返回地址的链接\n去掉unsigned的指令集依然是完整的\n至少需要一条syscall才能使用操作系统，否则指令集无法区分用户态和核心态\n务必注意当input的取值是最后一个值的时候的output\nCPU = 数据通路 + 控制逻辑\n指令在指令存储器中存储，地址为PC\n每执行完一条指令，PC = PC + 4\n指令存储器是一个静态存储器，所有写的端口恒为0\nadd.w: 从寄存器堆读取操作数，相加，写回寄存器堆\n寄存器堆的读端口必须有两个，否则执行add需要两个周期；而写端口要有enable（或者reset）\naddi.w: 与add.w唯一的区别就是第二个源操作数来自指令集中立即数符号扩展至32位\nld.w可以复用addi.w的数据通路，ld.w从从数据存储器中读取数据，取回的数据与加法器结果二选一放入寄存器堆\nst.w写数据存储器，不写寄存器堆\n务必注意：st.w的源操作数来自rd域，因为增加一个读端口会增加硬件开销\ndest bne = PC + offset\nbne根据判断的结果决定是否跳转\n每次加指令时进行的检查：本条指令是否正确运行，已有的指令功能是否正常\nzero寄存器的作用就是减少实现指令集子集时的xor\n编写控制信号的真值表\n存储器本质上属于核外单元，一些实际的案例中CPU的最顶层只有CLK和RESET\n现如今的EDA几乎可以把电路性能优化到极致，所以要以可读性与可维护性作为更高的目标\n不要写真值表，画卡诺图，直接对照指令的机器码格式和电路图敲Verilog\n多一条assign可以提高代码可读性\nb: 立即数增宽至26位\nbl:b之后将PC + 4写入r1（单周期甚至可以直接拉线到MUX写入）\n新增的控制信号依然要考虑所有的指令\n","date":"2024-12-10T16:55:17+08:00","permalink":"https://vzstless.moe/p/%E5%8D%95%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8la%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/","title":"单周期处理器（LA）讲座笔记"},{"content":"（注：这篇文章成文于一年前，放在博客上只是为了留档）\n最开始接触这玩意儿其实是因为前端（一朝做贼，再想做好人可不容易啊），菜鸟教程推荐的编辑器里头有VSCode，Sublime和WebStorm，这仨里头VSC配C的环境给我配出心理阴影了，而且这玩意儿甚至原生不支持ctrl+滚轮缩放字体。WS要钱，一年两千八，我说我别tm做个前端还得贴钱打工，于是选了Sublime，不得不承认这玩意儿确实好使得一批，现在除了C，Python和Mathematica直接Sublime+命令行，真正做到了有高亮有编译器就能写。\n这篇文章的内容全部为个人总结，毕竟网上能找到的Sublime教程都挺乐色的。\n基本使用方法 下载的话直接下就行，这玩意儿反正免费，不过保存文件的时候会时不时蹦个小窗口要你买License，有点烦人，不必管它。\n建议使用原生英文环境，毕竟那几个单词也不难，中文得装包，而且多语言包其实不好用，有一些词语原来是英文到头还是英文。\n双击快捷方式进入，View，SideBar，Show SideBar，调出来侧边栏，这样你就能看到你打开的文件。\nFile，New File可以新创建一个文件（注意这个文件是缺少后缀的），Open File可以打开一个文件并自动匹配高亮。\nNew File之后的第一件事务必先View，Syntax里头找这个语言的高亮，这不仅可以给你敲代码带来方便还能为你的代码文件添加对应的后缀（比如C的.c，Python的.py）\n一些关键字，头文件和函数会有对应的联想，如果想使用这些联想（或者叫补全）就即使按下Tab应用。\n敲完代码后ctrl+S保存\n高级技巧（也许？） ctrl+shift+P会打开一个搜索框，输入install，找到PackageInstaller就可以安装一些包让你的sublime变得花里胡哨。\n卸载Package输入remove即可\n比如你想要某个语言的高亮而Syntax找不见的时候就可以搜索这个语言的名称安装高亮和文件后缀支持。 搜索Chinese可以找到多语言支持不过不好使。 Emmet，直到我从前端滚蛋了四个月我才装这个包\nctrl+F在文件中进行搜索\n左手双指滑动右手按住鼠标就可以控制选中文本的速度，适用于没怎么学快捷键而单用鼠标控制不住文本选择的人\nctrl+P添加//注释\nctrl+shift+P添加/* 注释* /\nctrl+F 全局查找对应关键词\n至于其他的快捷键可以直接搜索对应关键词，不过我没咋用过别的快捷键就是了\nEdit里的Undo和Redo可以用来吃后悔药\n没保存也没关系，Sublime的逻辑是打开后自动开启上个工作文件的已有进程\n每行旁边如果有个倒三角可以进行代码缩略（常见于函数和CSS样式表）（这玩意儿在编CSS的时候救了我的老命要不然眼睛迟早得完蛋）\n右侧的代码预览可以快速转移至文件的某处代码\n环境变量中添加\u0026hellip;\u0026hellip;\\Sublime Text后可以使用Sublime的shell命令\nsubl 直接打开\nsubl 文件名 新建文件（Sublime直至你指定前不进行文件保存工作）\n","date":"2024-12-10T16:52:35+08:00","permalink":"https://vzstless.moe/p/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8Bsublime/","title":"一分钟上手Sublime"},{"content":"4.1 prelude PC holds the address of the instruction that currently executed.\nregisters, base pointer, stack pointer\ncondition code: ZF, SF, OF\nmemory(monolithic byte array)\nTypes of encoding the Y-86 instructions:\nI-type, D-type and B-type\ninstructions movq is split: I, R, M -\u0026gt; R, M\nAL instructions: addq, subq, andq, xorq (as there is no zero register in Y-86 processor, you must add an xorq instruction)\njumps: jmp, \u0026lt;=, \u0026lt;, ==, !=, \u0026gt;=, \u0026gt;\ncond move: \u0026lt;=, \u0026lt;, ==, !=, \u0026gt;=, \u0026gt;\nhalt: stops the program\nencode code + function\nstore in a small RAM\nno ambiguity when encoding the instructions\nY86-64 is CISC-like for its various length of instructions and RISC-like for its single load/store encoding\nexceptions AOK, HLT, ADR, INS\nshut whenever not AOK\nrun a code addq needs another register but subq can also set the stat code\npushq and popq\u0026rsquo;s details may largely reduce the code portability, problem may occur when subq compares rsp and the pushed value, or pop the stack pointer, undefined behavior always annoy people anytime anywhere.\n4.2 components combinational logic, memory elements, clock signals(sequential logic is split into two parts)\nsimilarity: Verilog -\u0026gt; C, VHDL -\u0026gt; Ada\nHCL == block:\nbool eq = (a \u0026amp;\u0026amp; b) || (!a \u0026amp;\u0026amp; !b)\nHCL MUX block:\nbool out = (s \u0026amp;\u0026amp; a) || ()\nword level: using cases\n1 2 3 4 word Out = [ s: A; 1: B; ]; sequential logic reg \u0026amp; RAM\nstate changes only when clock rises\nsimple regfile:\nvalA, valB, srcA, srcB, dstW, valW\nin the Y86 processor: a memory with 2 ports, one for R inst, the other for R/W data\n4.3 stages of instructions Fetch PC = memaddr\nvalP = PC + len(inst)\nDecode read operands from reg file\nExecute ALU performs instruction or incr/decr the stack pointer, for other instruction, similar\nMemory W/R data in mem\nWrite back write back to register\nPC update PC stores addr of next instruction\ncost of adding hardware \u0026gt; cost of copying code in software\nprocess similar instructions in same manners\nHardware Fetch: PC computes valP, the incremented PC.\nDecode: read valA and valB\nExecute: ALU calculates integer or increments the stack pointer, decides whether jump or not.\nMemory: read or write a word of mem\nWrite Back: write back from ALU or mem\nPC update\nonly start next cycle when clock rises\nprocessor never read back\neg: no instruction will both set and read the cond code\neg: stack pointer\nfetch: fetching 6 bytes and generate instruction fields.\ndecode \u0026amp; write back: generate register identifiers, serve necessary data.\nexecute: ALU performs as the calculator or just the adder.\nmemory: write or read memory values.\nPC increment: depend on instruction code or branch or not.\nSurvey the clock must run slow enough to suit the single-cycle.\nthe parts of the processor only active for a single part of time in the clock cycle\n4.4 pipelining divide into a series of discrete stages\nincrease the throughput of a system, but slightly increase the latency\nnonpipelined: a logic performs the computation with a register hold the result of the computation\nlatency: the total time to perform a single instruction\nslowing the clock won\u0026rsquo;t change the behavior of a pipeline.\ndifferent clock delays of different instructions influences the pipeline,\ndue to the delay, pipeline doesn\u0026rsquo;t always have larger throughput with more stages on each instruction\nlogical dependencies limits the performance of pipeline\n","date":"2024-12-10T16:44:47+08:00","permalink":"https://vzstless.moe/p/csapp-chapter4/","title":"Csapp Chapter4"},{"content":"(This is the first version of my README)\nVZstless as your friend or thinker 🍥 Call this name as VictorZhang was signed up by somebody else\u0026hellip; 👻 Love frontend in any perspective, digital, or web. 🐣 Libre \u0026amp; OpenSource aholic. ⭐ Still an undergraduate and a crazyone. 🐧 A human-like history book or cheatsheet. ✉️ 2319725508@qq.com 🍀I work so I live. ","date":"2024-12-09T20:45:32+08:00","permalink":"https://vzstless.moe/p/whoami/","title":"Whoami"}]